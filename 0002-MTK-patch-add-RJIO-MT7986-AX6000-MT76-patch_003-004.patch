From 8b21d11ea046d32d11904beb22bcef9754b86a78 Mon Sep 17 00:00:00 2001
From: Justin Tsai <justin@gmail.com>
Date: Wed, 10 May 2023 10:20:11 +0800
Subject: [PATCH 02/12] [MTK patch] add
 [RJIO][MT7986][AX6000][MT76]patch_003-004. including: 1.tx statistics counter
 patch
 openwrt/package/kernel/mt76/patches/3015-wifi-mt76-update-tx-statistics.patch
 2.flowblock patches
 openwrt/target/linux/mediatek/patches-5.4/9990-mt7622-backport-nf-hw-offload-framework-and-ups.patch
 openwrt/target/linux/mediatek/patches-5.4/9999-2-flow-offload-add-mtkhnat-flow-accounting.patch
 openwrt/target/linux/mediatek/patches-5.4/9999-3-flow-offload-add-mtkhnat-qdma-qos.patch

---
 .../3015-wifi-mt76-update-tx-statistics.patch      | 668 +++++++++++++++++++++
 ...-backport-nf-hw-offload-framework-and-ups.patch | 314 ++++++----
 ...-flow-offload-add-mtkhnat-flow-accounting.patch | 123 ++--
 .../9999-3-flow-offload-add-mtkhnat-qdma-qos.patch | 181 +++---
 4 files changed, 1037 insertions(+), 249 deletions(-)
 create mode 100755 openwrt/package/kernel/mt76/patches/3015-wifi-mt76-update-tx-statistics.patch

diff --git a/openwrt/package/kernel/mt76/patches/3015-wifi-mt76-update-tx-statistics.patch b/openwrt/package/kernel/mt76/patches/3015-wifi-mt76-update-tx-statistics.patch
new file mode 100755
index 0000000..66cfd26
--- /dev/null
+++ b/openwrt/package/kernel/mt76/patches/3015-wifi-mt76-update-tx-statistics.patch
@@ -0,0 +1,668 @@
+From 31b896859371fde2cda7d8599c67e06c7c69e162 Mon Sep 17 00:00:00 2001
+From: mtk27745 <rex.lu@mediatek.com>
+Date: Fri, 7 Apr 2023 17:24:10 +0800
+Subject: [PATCH] wifi: mt76: update tx statistics
+
+---
+ mt76.h               |   3 +-
+ mt76_connac2_mac.h   |   1 +
+ mt76_connac_mac.c    |  11 ++-
+ mt76_connac_mcu.h    |   2 +
+ mt7915/init.c        |   6 ++
+ mt7915/mac.c         |  17 +++--
+ mt7915/mac.h         |   5 +-
+ mt7915/main.c        |  22 +++---
+ mt7915/mcu.c         | 164 ++++++++++++++++++++++++++++++++++++++++++-
+ mt7915/mcu.h         |  33 +++++++++
+ mt7915/mmio.c        |  21 ------
+ mt7915/mt7915.h      |   2 +
+ mt7915/mtk_debugfs.c |  62 ++++++++++++++++
+ tx.c                 |  14 ++++
+ 14 files changed, 315 insertions(+), 48 deletions(-)
+ mode change 100755 => 100644 mt7915/init.c
+
+diff --git a/mt76.h b/mt76.h
+index 631c4cc..ea94dd3 100644
+--- a/mt76.h
++++ b/mt76.h
+@@ -282,7 +282,8 @@ struct mt76_sta_stats {
+ 	u64 tx_mcs[16];		/* mcs idx */
+ 	u64 tx_bytes;
+ 	/* WED TX */
+-	u32 tx_packets;
++	u32 tx_packets;		/* unit: MSDU */
++	u32 tx_mpdu_cnt;
+ 	u32 tx_retries;
+ 	u32 tx_failed;
+ 	/* WED RX */
+diff --git a/mt76_connac2_mac.h b/mt76_connac2_mac.h
+index f33171b..101e760 100644
+--- a/mt76_connac2_mac.h
++++ b/mt76_connac2_mac.h
+@@ -164,6 +164,7 @@ enum {
+ 
+ #define MT_TXS6_MPDU_FAIL_CNT		GENMASK(31, 23)
+ 
++#define MT_TXS7_MPDU_RETRY_BYTE		GENMASK(22, 0)
+ #define MT_TXS7_MPDU_RETRY_CNT		GENMASK(31, 23)
+ 
+ /* RXD DW1 */
+diff --git a/mt76_connac_mac.c b/mt76_connac_mac.c
+index c8d0c84..1910818 100644
+--- a/mt76_connac_mac.c
++++ b/mt76_connac_mac.c
+@@ -489,8 +489,8 @@ void mt76_connac2_mac_write_txwi(struct mt76_dev *dev, __le32 *txwi,
+ 			mt76_connac_lmac_mapping(skb_get_queue_mapping(skb));
+ 
+ 		/* counting non-offloading skbs */
+-		wcid->stats.tx_bytes += skb->len;
+-		wcid->stats.tx_packets++;
++		if (is_mt7915(dev))
++			wcid->stats.tx_packets++;
+ 	}
+ 
+ 	val = FIELD_PREP(MT_TXD0_TX_BYTES, skb->len + sz_txd) |
+@@ -574,11 +574,8 @@ bool mt76_connac2_mac_fill_txs(struct mt76_dev *dev, struct mt76_wcid *wcid,
+ 	/* PPDU based reporting */
+ 	if (FIELD_GET(MT_TXS0_TXS_FORMAT, txs) > 1) {
+ 		stats->tx_bytes +=
+-			le32_get_bits(txs_data[5], MT_TXS5_MPDU_TX_BYTE);
+-		stats->tx_packets +=
+-			le32_get_bits(txs_data[5], MT_TXS5_MPDU_TX_CNT);
+-		stats->tx_failed +=
+-			le32_get_bits(txs_data[6], MT_TXS6_MPDU_FAIL_CNT);
++			le32_get_bits(txs_data[5], MT_TXS5_MPDU_TX_BYTE) -
++			le32_get_bits(txs_data[7], MT_TXS7_MPDU_RETRY_BYTE);
+ 		stats->tx_retries +=
+ 			le32_get_bits(txs_data[7], MT_TXS7_MPDU_RETRY_CNT);
+ 	}
+diff --git a/mt76_connac_mcu.h b/mt76_connac_mcu.h
+index 239643b..3e2872c 100644
+--- a/mt76_connac_mcu.h
++++ b/mt76_connac_mcu.h
+@@ -998,6 +998,7 @@ enum {
+ 	MCU_EXT_EVENT_BF_STATUS_READ = 0x35,
+ 	MCU_EXT_EVENT_RDD_REPORT = 0x3a,
+ 	MCU_EXT_EVENT_CSA_NOTIFY = 0x4f,
++	MCU_EXT_EVENT_WA_TX_STAT = 0x74,
+ 	MCU_EXT_EVENT_BCC_NOTIFY = 0x75,
+ 	MCU_EXT_EVENT_MURU_CTRL = 0x9f,
+ 	MCU_EXT_EVENT_CSI_REPORT = 0xc2,
+@@ -1157,6 +1158,7 @@ enum {
+ 	MCU_EXT_CMD_EDCA_UPDATE = 0x27,
+ 	MCU_EXT_CMD_DEV_INFO_UPDATE = 0x2A,
+ 	MCU_EXT_CMD_THERMAL_CTRL = 0x2c,
++	MCU_EXT_CMD_GET_TX_STAT = 0x30,
+ 	MCU_EXT_CMD_WTBL_UPDATE = 0x32,
+ 	MCU_EXT_CMD_SET_DRR_CTRL = 0x36,
+ 	MCU_EXT_CMD_SET_FEATURE_CTRL = 0x38,
+diff --git a/mt7915/init.c b/mt7915/init.c
+old mode 100755
+new mode 100644
+index ef752e1..b149677
+--- a/mt7915/init.c
++++ b/mt7915/init.c
+@@ -495,6 +495,12 @@ mt7915_mac_init_band(struct mt7915_dev *dev, u8 band)
+ 	set = FIELD_PREP(MT_WTBLOFF_TOP_RSCR_RCPI_MODE, 0) |
+ 	      FIELD_PREP(MT_WTBLOFF_TOP_RSCR_RCPI_PARAM, 0x3);
+ 	mt76_rmw(dev, MT_WTBLOFF_TOP_RSCR(band), mask, set);
++
++	/* MT_TXD5_TX_STATUS_HOST (MPDU format) has higher priority than
++	 * MT_AGG_ACR_PPDU_TXS2H (PPDU format) even though ACR bit is set.
++	 */
++	if (mtk_wed_device_active(&dev->mt76.mmio.wed))
++		mt76_set(dev, MT_AGG_ACR4(band), MT_AGG_ACR_PPDU_TXS2H);
+ }
+ 
+ static void
+diff --git a/mt7915/mac.c b/mt7915/mac.c
+index 0d0ae7a..7529618 100644
+--- a/mt7915/mac.c
++++ b/mt7915/mac.c
+@@ -1018,6 +1018,7 @@ mt7915_mac_tx_free(struct mt7915_dev *dev, void *data, int len)
+ 	struct mt76_dev *mdev = &dev->mt76;
+ 	struct mt76_txwi_cache *txwi;
+ 	struct ieee80211_sta *sta = NULL;
++	struct mt76_wcid *wcid = NULL;
+ 	LIST_HEAD(free_list);
+ 	void *end = data + len;
+ 	bool v3, wake = false;
+@@ -1032,7 +1033,7 @@ mt7915_mac_tx_free(struct mt7915_dev *dev, void *data, int len)
+ 	v3 = (FIELD_GET(MT_TX_FREE_VER, txd) == 0x4);
+ 
+ 	for (cur_info = tx_info; count < total; cur_info++) {
+-		u32 msdu, info;
++		u32 msdu, info, retries = 0;
+ 		u8 i;
+ 
+ 		if (WARN_ON_ONCE((void *)cur_info >= end))
+@@ -1045,7 +1046,6 @@ mt7915_mac_tx_free(struct mt7915_dev *dev, void *data, int len)
+ 		info = le32_to_cpu(*cur_info);
+ 		if (info & MT_TX_FREE_PAIR) {
+ 			struct mt7915_sta *msta;
+-			struct mt76_wcid *wcid = NULL;
+ 			u16 idx;
+ 
+ 			idx = FIELD_GET(MT_TX_FREE_WLAN_ID, info);
+@@ -1062,7 +1062,15 @@ mt7915_mac_tx_free(struct mt7915_dev *dev, void *data, int len)
+ 			continue;
+ 		}
+ 
+-		if (v3 && (info & MT_TX_FREE_MPDU_HEADER))
++		if (v3 && (info & MT_TX_FREE_MPDU_HEADER_V3))
++			retries = u32_get_bits(info, MT_TX_FREE_TX_COUNT_V3) - 1;
++		else if (!v3 && (info & MT_TX_FREE_MPDU_HEADER))
++			retries = u32_get_bits(info, MT_TX_FREE_TX_COUNT) - 1;
++
++		if (!mtk_wed_device_active(&mdev->mmio.wed) && wcid)
++			wcid->stats.tx_retries += retries;
++
++		if (v3 && (info & MT_TX_FREE_MPDU_HEADER_V3))
+ 			continue;
+ 
+ 		for (i = 0; i < 1 + v3; i++) {
+@@ -1126,9 +1134,6 @@ static void mt7915_mac_add_txs(struct mt7915_dev *dev, void *data)
+ 	u16 wcidx;
+ 	u8 pid;
+ 
+-	if (le32_get_bits(txs_data[0], MT_TXS0_TXS_FORMAT) > 1)
+-		return;
+-
+ 	wcidx = le32_get_bits(txs_data[2], MT_TXS2_WCID);
+ 	pid = le32_get_bits(txs_data[3], MT_TXS3_PID);
+ 
+diff --git a/mt7915/mac.h b/mt7915/mac.h
+index 6fa9c79..afadc51 100644
+--- a/mt7915/mac.h
++++ b/mt7915/mac.h
+@@ -36,8 +36,11 @@ enum rx_pkt_type {
+ #define MT_TX_FREE_LATENCY		GENMASK(12, 0)
+ /* 0: success, others: dropped */
+ #define MT_TX_FREE_MSDU_ID		GENMASK(30, 16)
++#define MT_TX_FREE_TX_COUNT		GENMASK(12, 0)
++#define MT_TX_FREE_TX_COUNT_V3		GENMASK(27, 24)
+ #define MT_TX_FREE_PAIR			BIT(31)
+-#define MT_TX_FREE_MPDU_HEADER		BIT(30)
++#define MT_TX_FREE_MPDU_HEADER		BIT(15)
++#define MT_TX_FREE_MPDU_HEADER_V3	BIT(30)
+ #define MT_TX_FREE_MSDU_ID_V3		GENMASK(14, 0)
+ 
+ /* will support this field in further revision */
+diff --git a/mt7915/main.c b/mt7915/main.c
+index c87f04b..cb8d0c3 100644
+--- a/mt7915/main.c
++++ b/mt7915/main.c
+@@ -1103,15 +1103,6 @@ static void mt7915_sta_statistics(struct ieee80211_hw *hw,
+ 		sinfo->tx_bytes = msta->wcid.stats.tx_bytes;
+ 		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BYTES64);
+ 
+-		sinfo->tx_packets = msta->wcid.stats.tx_packets;
+-		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_PACKETS);
+-
+-		sinfo->tx_failed = msta->wcid.stats.tx_failed;
+-		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_FAILED);
+-
+-		sinfo->tx_retries = msta->wcid.stats.tx_retries;
+-		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_RETRIES);
+-
+ 		if (mtk_wed_get_rx_capa(&phy->dev->mt76.mmio.wed)) {
+ 			sinfo->rx_bytes = msta->wcid.stats.rx_bytes;
+ 			sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BYTES64);
+@@ -1121,6 +1112,19 @@ static void mt7915_sta_statistics(struct ieee80211_hw *hw,
+ 		}
+ 	}
+ 
++	sinfo->tx_retries = msta->wcid.stats.tx_retries;
++	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_RETRIES);
++
++	if (!mt7915_mcu_get_tx_stat_wa(phy->dev, msta->wcid.idx)) {
++		sinfo->tx_packets = msta->wcid.stats.tx_packets;
++		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_PACKETS);
++	}
++
++	if (!mt7915_get_tx_stat(phy, msta->wcid.idx)) {
++		sinfo->tx_failed = msta->wcid.stats.tx_failed;
++		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_FAILED);
++	}
++
+ 	sinfo->ack_signal = (s8)msta->ack_signal;
+ 	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL);
+ 
+diff --git a/mt7915/mcu.c b/mt7915/mcu.c
+index 387967d..8fcc281 100644
+--- a/mt7915/mcu.c
++++ b/mt7915/mcu.c
+@@ -168,7 +168,9 @@ mt7915_mcu_parse_response(struct mt76_dev *mdev, int cmd,
+ 	}
+ 
+ 	rxd = (struct mt76_connac2_mcu_rxd *)skb->data;
+-	if (seq != rxd->seq)
++
++	if (seq != rxd->seq &&
++	    !(rxd->eid == MCU_CMD_EXT_CID && rxd->ext_eid == MCU_EXT_EVENT_WA_TX_STAT))
+ 		return -EAGAIN;
+ 
+ 	if (cmd == MCU_CMD(PATCH_SEM_CONTROL)) {
+@@ -420,13 +422,14 @@ void mt7915_mcu_rx_event(struct mt7915_dev *dev, struct sk_buff *skb)
+ 	struct mt76_connac2_mcu_rxd *rxd;
+ 
+ 	rxd = (struct mt76_connac2_mcu_rxd *)skb->data;
+-	if (rxd->ext_eid == MCU_EXT_EVENT_THERMAL_PROTECT ||
++	if ((rxd->ext_eid == MCU_EXT_EVENT_THERMAL_PROTECT ||
+ 	    rxd->ext_eid == MCU_EXT_EVENT_FW_LOG_2_HOST ||
+ 	    rxd->ext_eid == MCU_EXT_EVENT_ASSERT_DUMP ||
+ 	    rxd->ext_eid == MCU_EXT_EVENT_PS_SYNC ||
+ 	    rxd->ext_eid == MCU_EXT_EVENT_BCC_NOTIFY ||
+ 	    rxd->ext_eid == MCU_EXT_EVENT_BF_STATUS_READ ||
+-	    !rxd->seq)
++	    !rxd->seq) &&
++	    !(rxd->eid == MCU_CMD_EXT_CID && rxd->ext_eid == MCU_EXT_EVENT_WA_TX_STAT))
+ 		mt7915_mcu_rx_unsolicited_event(dev, skb);
+ 	else
+ 		mt76_mcu_rx_event(&dev->mt76, skb);
+@@ -4040,6 +4043,161 @@ out:
+ 	return ret;
+ }
+ 
++int mt7915_mcu_get_tx_stat_wa(struct mt7915_dev *dev, u16 wlan_idx)
++{
++	struct {
++		__le32 cmd;
++		__le32 num;
++		__le32 __rsv;
++		__le16 wlan_idx;
++	} req = {
++		.cmd = cpu_to_le32(MCU_WA_QUERY_GET_TX_STAT),
++		.num = cpu_to_le32(1),
++		.wlan_idx = cpu_to_le16(wlan_idx),
++	};
++	struct mt7915_mcu_wa_tx_stat *res;
++	struct mt76_wcid *wcid;
++	struct sk_buff *skb;
++	int ret;
++
++	ret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_WA_PARAM_CMD(QUERY),
++					&req, sizeof(req), true, &skb);
++	if (ret)
++		return ret;
++
++	if (!is_mt7915(&dev->mt76))
++		skb_pull(skb, 4);
++
++	res = (struct mt7915_mcu_wa_tx_stat *)skb->data;
++
++	if (le16_to_cpu(res->wlan_idx) != wlan_idx) {
++		ret = -EINVAL;
++		goto out;
++	}
++
++	rcu_read_lock();
++
++	wcid = rcu_dereference(dev->mt76.wcid[wlan_idx]);
++	if (wcid)
++		wcid->stats.tx_packets += le32_to_cpu(res->tx_msdu_cnt);
++	else
++		ret = -EINVAL;
++
++	rcu_read_unlock();
++out:
++	dev_kfree_skb(skb);
++
++	return ret;
++}
++
++static int mt7915_mcu_get_tx_stat_v1(struct mt7915_phy *phy,
++				     u16 wlan_idx)
++{
++#define to_wcid(hi, lo) (hi << 8 | lo)
++	struct mt7915_dev *dev = phy->dev;
++	struct mt76_phy *mphy = phy->mt76;
++	struct mt7915_mcu_tx_stat_v1 *res;
++	struct mt76_wcid *wcid;
++	struct sk_buff *skb;
++	struct {
++		__le32 category;
++		u8 wlan_idx_lo;
++		u8 band;
++		u8 wlan_idx_hi;
++		u8 __rsv[5];
++	} __packed req = {
++		.category = cpu_to_le32(MCU_GET_TX_STAT_CNT),
++		.band = mphy->band_idx,
++		.wlan_idx_lo = to_wcid_lo(wlan_idx),
++		.wlan_idx_hi = to_wcid_hi(wlan_idx),
++	};
++	int ret;
++
++	ret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_EXT_QUERY(GET_TX_STAT),
++					&req, sizeof(req), true, &skb);
++	if (ret)
++		return ret;
++
++	res = (struct mt7915_mcu_tx_stat_v1 *)skb->data;
++
++	if (to_wcid(res->wlan_idx_hi, res->wlan_idx_lo) != wlan_idx) {
++		ret = -EINVAL;
++		goto out;
++	}
++
++	rcu_read_lock();
++
++	wcid = rcu_dereference(dev->mt76.wcid[wlan_idx]);
++	if (wcid) {
++		wcid->stats.tx_mpdu_cnt += le32_to_cpu(res->tx_cnt);
++		wcid->stats.tx_failed += le32_to_cpu(res->tx_failed);
++	} else {
++		ret = -EINVAL;
++	}
++
++	rcu_read_unlock();
++out:
++	dev_kfree_skb(skb);
++
++	return ret;
++}
++
++static int mt7915_mcu_get_tx_stat_v2(struct mt7915_phy *phy,
++				     u16 wlan_idx)
++{
++	struct mt7915_dev *dev = phy->dev;
++	struct mt76_phy *mphy = phy->mt76;
++	struct mt7915_mcu_tx_stat_v2 *res;
++	struct mt76_wcid *wcid;
++	struct sk_buff *skb;
++	struct {
++		u8 category;
++		u8 band;
++		__le16 wcid;
++	} __packed req = {
++		.category = MCU_GET_TX_STAT_CNT,
++		.band = mphy->band_idx,
++		.wcid = cpu_to_le16(wlan_idx),
++	};
++	int ret;
++
++	ret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_EXT_QUERY(GET_TX_STAT),
++					&req, sizeof(req), true, &skb);
++	if (ret)
++		return ret;
++
++	res = (struct mt7915_mcu_tx_stat_v2 *)skb->data;
++
++	if (le16_to_cpu(res->wlan_idx) != wlan_idx) {
++		ret = -EINVAL;
++		goto out;
++	}
++
++	rcu_read_lock();
++
++	wcid = rcu_dereference(dev->mt76.wcid[wlan_idx]);
++	if (wcid) {
++		wcid->stats.tx_mpdu_cnt += le32_to_cpu(res->tx_cnt);
++		wcid->stats.tx_failed += le32_to_cpu(res->tx_failed);
++	} else {
++		ret = -EINVAL;
++	}
++
++	rcu_read_unlock();
++out:
++	dev_kfree_skb(skb);
++
++	return ret;
++}
++
++int mt7915_get_tx_stat(struct mt7915_phy *phy, u16 wlan_idx)
++{
++	if (is_mt7915(&phy->dev->mt76))
++		return mt7915_mcu_get_tx_stat_v1(phy, wlan_idx);
++
++	return mt7915_mcu_get_tx_stat_v2(phy, wlan_idx);
++}
++
+ int mt7915_mcu_update_bss_color(struct mt7915_dev *dev, struct ieee80211_vif *vif,
+ 				struct cfg80211_he_bss_color *he_bss_color)
+ {
+diff --git a/mt7915/mcu.h b/mt7915/mcu.h
+index 572cc16..7961818 100644
+--- a/mt7915/mcu.h
++++ b/mt7915/mcu.h
+@@ -292,6 +292,17 @@ enum {
+ #endif
+ };
+ 
++enum {
++	MCU_WA_QUERY_GET_TX_STAT = 0x15,
++};
++
++struct mt7915_mcu_wa_tx_stat {
++	__le16 wlan_idx;
++	u8 __rsv2[2];
++	__le32 tx_bytes;
++	__le32 tx_msdu_cnt;
++};
++
+ enum mcu_mmps_mode {
+ 	MCU_MMPS_STATIC,
+ 	MCU_MMPS_DYNAMIC,
+@@ -998,6 +1009,28 @@ struct mt7915_muru {
+ /* DL&UL User config */
+ #define MURU_USER_CNT                   BIT(4)
+ 
++struct mt7915_mcu_tx_stat_v1 {
++	u8 wlan_idx_lo;
++	u8 band_idx;
++	u8 wlan_idx_hi;
++	u8 __rsv1[29];
++	__le32 tx_cnt;
++	__le32 tx_failed;
++	u8 __rsv2[26];
++};
++
++struct mt7915_mcu_tx_stat_v2 {
++	u8 __rsv1[4];
++	__le16 wlan_idx;
++	u8 __rsv2[2];
++	__le32 tx_cnt;
++	__le32 tx_failed;
++};
++
++enum {
++	MCU_GET_TX_STAT_CNT = 8,
++};
++
+ enum {
+    CAPI_SU,
+    CAPI_MU,
+diff --git a/mt7915/mmio.c b/mt7915/mmio.c
+index 419338c..5c26738 100644
+--- a/mt7915/mmio.c
++++ b/mt7915/mmio.c
+@@ -549,7 +549,6 @@ static u32 mt7915_rmw(struct mt76_dev *mdev, u32 offset, u32 mask, u32 val)
+ static int mt7915_mmio_wed_offload_enable(struct mtk_wed_device *wed)
+ {
+ 	struct mt7915_dev *dev;
+-	struct mt7915_phy *phy;
+ 	int ret;
+ 
+ 	dev = container_of(wed, struct mt7915_dev, mt76.mmio.wed);
+@@ -563,38 +562,18 @@ static int mt7915_mmio_wed_offload_enable(struct mtk_wed_device *wed)
+ 	if (!ret)
+ 		return -EAGAIN;
+ 
+-	phy = &dev->phy;
+-	mt76_set(dev, MT_AGG_ACR4(phy->mt76->band_idx), MT_AGG_ACR_PPDU_TXS2H);
+-
+-	phy = dev->mt76.phys[MT_BAND1] ? dev->mt76.phys[MT_BAND1]->priv : NULL;
+-	if (phy)
+-		mt76_set(dev, MT_AGG_ACR4(phy->mt76->band_idx),
+-			 MT_AGG_ACR_PPDU_TXS2H);
+-
+ 	return 0;
+ }
+ 
+ static void mt7915_mmio_wed_offload_disable(struct mtk_wed_device *wed)
+ {
+ 	struct mt7915_dev *dev;
+-	struct mt7915_phy *phy;
+ 
+ 	dev = container_of(wed, struct mt7915_dev, mt76.mmio.wed);
+ 
+ 	spin_lock_bh(&dev->mt76.token_lock);
+ 	dev->mt76.token_size = wed->wlan.token_start;//MT7915_TOKEN_SIZE
+ 	spin_unlock_bh(&dev->mt76.token_lock);
+-
+-	/* MT_TXD5_TX_STATUS_HOST (MPDU format) has higher priority than
+-	 * MT_AGG_ACR_PPDU_TXS2H (PPDU format) even though ACR bit is set.
+-	 */
+-	phy = &dev->phy;
+-	mt76_clear(dev, MT_AGG_ACR4(phy->mt76->band_idx), MT_AGG_ACR_PPDU_TXS2H);
+-
+-	phy = dev->mt76.phys[MT_BAND1] ? dev->mt76.phys[MT_BAND1]->priv : NULL;
+-	if (phy)
+-		mt76_clear(dev, MT_AGG_ACR4(phy->mt76->band_idx),
+-			   MT_AGG_ACR_PPDU_TXS2H);
+ }
+ 
+ static void mt7915_mmio_wed_release_rx_buf(struct mtk_wed_device *wed)
+diff --git a/mt7915/mt7915.h b/mt7915/mt7915.h
+index 91b98ed..767a5fa 100644
+--- a/mt7915/mt7915.h
++++ b/mt7915/mt7915.h
+@@ -713,6 +713,8 @@ int mt7915_mcu_set_thermal_throttling(struct mt7915_phy *phy, u8 state);
+ int mt7915_mcu_set_thermal_protect(struct mt7915_phy *phy);
+ int mt7915_mcu_get_rx_rate(struct mt7915_phy *phy, struct ieee80211_vif *vif,
+ 			   struct ieee80211_sta *sta, struct rate_info *rate);
++int mt7915_mcu_get_tx_stat_wa(struct mt7915_dev *dev, u16 wcid);
++int mt7915_get_tx_stat(struct mt7915_phy *phy, u16 wlan_idx);
+ int mt7915_mcu_rdd_background_enable(struct mt7915_phy *phy,
+ 				     struct cfg80211_chan_def *chandef);
+ int mt7915_mcu_rf_regval(struct mt7915_dev *dev, u32 regidx, u32 *val, bool set);
+diff --git a/mt7915/mtk_debugfs.c b/mt7915/mtk_debugfs.c
+index c8df2d0..5c35bdc 100644
+--- a/mt7915/mtk_debugfs.c
++++ b/mt7915/mtk_debugfs.c
+@@ -3123,6 +3123,66 @@ mt7915_sw_aci_set(void *data, u64 val)
+ DEFINE_DEBUGFS_ATTRIBUTE(fops_sw_aci, NULL,
+ 			 mt7915_sw_aci_set, "%llx\n");
+ 
++static int mt7915_reset_counter(void *data, u64 val)
++{
++	struct mt7915_phy *phy = data;
++	struct mt7915_dev *dev = phy->dev;
++	struct mt76_wcid *wcid;
++
++	/* Clear the firmware counters */
++	mt7915_mcu_get_tx_stat_wa(dev, dev->wlan_idx);
++	mt7915_get_tx_stat(phy, dev->wlan_idx);
++
++	rcu_read_lock();
++	wcid = rcu_dereference(dev->mt76.wcid[dev->wlan_idx]);
++	if (!wcid)
++		return -EINVAL;
++
++	memset(&wcid->stats, 0, sizeof(struct mt76_sta_stats));
++
++	rcu_read_unlock();
++
++	return 0;
++}
++
++DEFINE_DEBUGFS_ATTRIBUTE(fops_reset_counter, NULL,
++			 mt7915_reset_counter, "%lld\n");
++
++static int
++mt7915_per_read(struct seq_file *s, void *data)
++{
++	struct mt7915_dev *dev = dev_get_drvdata(s->private);
++	struct mt76_sta_stats *stats;
++	struct mt76_wcid *wcid;
++	int ret;
++	u8 phy_idx;
++
++	if (!dev->mt76.wcid[dev->wlan_idx])
++		return -EINVAL;
++
++	phy_idx = dev->mt76.wcid[dev->wlan_idx]->phy_idx;
++
++	ret = mt7915_get_tx_stat(dev->mt76.phys[phy_idx]->priv, dev->wlan_idx);
++	if (ret)
++		return ret;
++
++	rcu_read_lock();
++	wcid = rcu_dereference(dev->mt76.wcid[dev->wlan_idx]);
++	if (!wcid)
++		return -EINVAL;
++
++	stats = &wcid->stats;
++
++	seq_printf(s, "sta %d, tx_mpdu_cnt = %u, tx_failed = %u,  PER = %u.%u%%\n", dev->wlan_idx,
++		   stats->tx_mpdu_cnt, stats->tx_failed,
++		   stats->tx_mpdu_cnt ? stats->tx_failed * 1000 / stats->tx_mpdu_cnt / 10 : 0,
++		   stats->tx_mpdu_cnt ? stats->tx_failed * 1000 / stats->tx_mpdu_cnt % 10 : 0);
++
++	rcu_read_unlock();
++
++	return 0;
++}
++
+ int mt7915_mtk_init_debugfs(struct mt7915_phy *phy, struct dentry *dir)
+ {
+ 	struct mt7915_dev *dev = phy->dev;
+@@ -3212,6 +3272,8 @@ int mt7915_mtk_init_debugfs(struct mt7915_phy *phy, struct dentry *dir)
+ 				    mt7915_show_eeprom_mode);
+ 	debugfs_create_file("sw_aci", 0600, dir, dev,
+ 			    &fops_sw_aci);
++	debugfs_create_file("reset_counter", 0200, dir, dev, &fops_reset_counter);
++	debugfs_create_devm_seqfile(dev->mt76.dev, "per", dir, mt7915_per_read);
+ 	return 0;
+ }
+ #endif
+diff --git a/tx.c b/tx.c
+index a72b777..c3c7eb5 100644
+--- a/tx.c
++++ b/tx.c
+@@ -120,6 +120,7 @@ mt76_tx_status_skb_add(struct mt76_dev *dev, struct mt76_wcid *wcid,
+ 		       struct sk_buff *skb)
+ {
+ 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
++	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+ 	struct mt76_tx_cb *cb = mt76_tx_skb_cb(skb);
+ 	int pid;
+ 
+@@ -131,6 +132,11 @@ mt76_tx_status_skb_add(struct mt76_dev *dev, struct mt76_wcid *wcid,
+ 	if (info->flags & IEEE80211_TX_CTL_NO_ACK)
+ 		return MT_PACKET_ID_NO_ACK;
+ 
++	if (mtk_wed_device_active(&dev->mmio.wed) &&
++	    ((info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP) ||
++	    ieee80211_is_data(hdr->frame_control)))
++		return MT_PACKET_ID_WED;
++
+ 	if (!(info->flags & (IEEE80211_TX_CTL_REQ_TX_STATUS |
+ 			     IEEE80211_TX_CTL_RATE_CTRL_PROBE)))
+ 		return MT_PACKET_ID_NO_SKB;
+@@ -230,6 +236,7 @@ mt76_tx_check_non_aql(struct mt76_dev *dev, struct mt76_wcid *wcid,
+ void __mt76_tx_complete_skb(struct mt76_dev *dev, u16 wcid_idx, struct sk_buff *skb,
+ 			    struct list_head *free_list)
+ {
++	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+ 	struct mt76_tx_cb *cb = mt76_tx_skb_cb(skb);
+ 	struct ieee80211_tx_status status = {
+ 		.skb = skb,
+@@ -262,6 +269,13 @@ void __mt76_tx_complete_skb(struct mt76_dev *dev, u16 wcid_idx, struct sk_buff *
+ 	if (cb->pktid < MT_PACKET_ID_FIRST) {
+ 		hw = mt76_tx_status_get_hw(dev, skb);
+ 		status.sta = wcid_to_sta(wcid);
++		if (mtk_wed_device_active(&dev->mmio.wed) &&
++		    (info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS)) {
++			if (status.sta) {
++				info->status.rates[0].idx = -1;
++				status.rate = &wcid->rate;
++			}
++		}
+ 		ieee80211_tx_status_ext(hw, &status);
+ 		goto out;
+ 	}
+-- 
+2.18.0
+
diff --git a/openwrt/target/linux/mediatek/patches-5.4/9990-mt7622-backport-nf-hw-offload-framework-and-ups.patch b/openwrt/target/linux/mediatek/patches-5.4/9990-mt7622-backport-nf-hw-offload-framework-and-ups.patch
index 813ccfc..f908fcc 100755
--- a/openwrt/target/linux/mediatek/patches-5.4/9990-mt7622-backport-nf-hw-offload-framework-and-ups.patch
+++ b/openwrt/target/linux/mediatek/patches-5.4/9990-mt7622-backport-nf-hw-offload-framework-and-ups.patch
@@ -1,17 +1,16 @@
-From 6ad9bd65769003ab526e504577e0f747eba14287 Mon Sep 17 00:00:00 2001
-From: Bo Jiao <Bo.Jiao@mediatek.com>
-Date: Wed, 22 Jun 2022 09:42:19 +0800
-Subject: [PATCH 1/8] 
- 9990-mt7622-backport-nf-hw-offload-framework-and-upstream-hnat-plus-xt-FLOWOFFLOAD-update-v2
+From 017760a9a027ef51fec8ef4d6c7095cea31af0c4 Mon Sep 17 00:00:00 2001
+From: mtk27745 <rex.lu@mediatek.com>
+Date: Mon, 17 Apr 2023 10:59:33 +0800
+Subject: [PATCH] 9990-mt7622-backport-nf-hw-offload-framework-and-ups
 
 ---
  drivers/net/ethernet/mediatek/Makefile        |    3 +-
- drivers/net/ethernet/mediatek/mtk_eth_soc.c   |   28 +-
+ drivers/net/ethernet/mediatek/mtk_eth_soc.c   |   25 +-
  drivers/net/ethernet/mediatek/mtk_eth_soc.h   |   20 +-
  drivers/net/ethernet/mediatek/mtk_ppe.c       |  509 +++++++
  drivers/net/ethernet/mediatek/mtk_ppe.h       |  288 ++++
  .../net/ethernet/mediatek/mtk_ppe_debugfs.c   |  214 +++
- .../net/ethernet/mediatek/mtk_ppe_offload.c   |  526 ++++++++
+ .../net/ethernet/mediatek/mtk_ppe_offload.c   |  541 ++++++++
  drivers/net/ethernet/mediatek/mtk_ppe_regs.h  |  144 ++
  drivers/net/ppp/ppp_generic.c                 |   22 +
  drivers/net/ppp/pppoe.c                       |   24 +
@@ -23,7 +22,7 @@ Subject: [PATCH 1/8]
  .../net/netfilter/ipv6/nf_conntrack_ipv6.h    |    3 -
  include/net/netfilter/nf_conntrack.h          |   12 +
  include/net/netfilter/nf_conntrack_acct.h     |   11 +
- include/net/netfilter/nf_flow_table.h         |  264 +++-
+ include/net/netfilter/nf_flow_table.h         |  266 +++-
  include/net/netns/conntrack.h                 |    6 +
  .../linux/netfilter/nf_conntrack_common.h     |    9 +-
  include/uapi/linux/netfilter/xt_FLOWOFFLOAD.h |   17 +
@@ -33,7 +32,7 @@ Subject: [PATCH 1/8]
  net/bridge/br_vlan.c                          |   55 +
  net/core/dev.c                                |   46 +
  net/dsa/dsa.c                                 |    9 +
- net/dsa/slave.c                               |   41 +-
+ net/dsa/slave.c                               |   37 +-
  net/ipv4/netfilter/Kconfig                    |    4 +-
  net/ipv6/ip6_output.c                         |    2 +-
  net/ipv6/netfilter/Kconfig                    |    3 +-
@@ -44,11 +43,11 @@ Subject: [PATCH 1/8]
  net/netfilter/nf_conntrack_proto_tcp.c        |    4 +
  net/netfilter/nf_conntrack_proto_udp.c        |    4 +
  net/netfilter/nf_conntrack_standalone.c       |   34 +-
- net/netfilter/nf_flow_table_core.c            |  446 +++---
- net/netfilter/nf_flow_table_ip.c              |  455 ++++---
- net/netfilter/nf_flow_table_offload.c         | 1191 +++++++++++++++++
- net/netfilter/xt_FLOWOFFLOAD.c                |  719 ++++++++++
- 43 files changed, 4913 insertions(+), 432 deletions(-)
+ net/netfilter/nf_flow_table_core.c            |  462 ++++---
+ net/netfilter/nf_flow_table_ip.c              |  447 +++---
+ net/netfilter/nf_flow_table_offload.c         | 1197 +++++++++++++++++
+ net/netfilter/xt_FLOWOFFLOAD.c                |  785 +++++++++++
+ 43 files changed, 5000 insertions(+), 435 deletions(-)
  create mode 100644 drivers/net/ethernet/mediatek/mtk_ppe.c
  create mode 100644 drivers/net/ethernet/mediatek/mtk_ppe.h
  create mode 100644 drivers/net/ethernet/mediatek/mtk_ppe_debugfs.c
@@ -59,10 +58,10 @@ Subject: [PATCH 1/8]
  create mode 100644 net/netfilter/xt_FLOWOFFLOAD.c
 
 diff --git a/drivers/net/ethernet/mediatek/Makefile b/drivers/net/ethernet/mediatek/Makefile
-index 13c5b4e8f..0a6af99f1 100755
+index 13d852c..cfffde4 100755
 --- a/drivers/net/ethernet/mediatek/Makefile
 +++ b/drivers/net/ethernet/mediatek/Makefile
-@@ -4,5 +4,6 @@
+@@ -4,6 +4,7 @@
  #
  
  obj-$(CONFIG_NET_MEDIATEK_SOC)			+= mtk_eth.o
@@ -70,11 +69,12 @@ index 13c5b4e8f..0a6af99f1 100755
 +mtk_eth-y := mtk_eth_soc.o mtk_sgmii.o mtk_usxgmii.o mtk_eth_path.o mtk_eth_dbg.o mtk_eth_reset.o	\
 +	     mtk_ppe.o mtk_ppe_debugfs.o mtk_ppe_offload.o
  obj-$(CONFIG_NET_MEDIATEK_HNAT)			+= mtk_hnat/
+ obj-$(CONFIG_XFRM_OFFLOAD)			+= mtk_ipsec.o
 diff --git a/drivers/net/ethernet/mediatek/mtk_eth_soc.c b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-index 2b21f7ed0..819d8a0be 100755
+index 19c4846..50e2d14 100755
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-@@ -3081,6 +3081,7 @@ static int mtk_open(struct net_device *d
+@@ -3082,6 +3082,7 @@ static int mtk_open(struct net_device *dev)
  	struct mtk_phylink_priv *phylink_priv = &mac->phylink_priv;
  	int err, i;
  	struct device_node *phy_node;
@@ -82,7 +82,7 @@ index 2b21f7ed0..819d8a0be 100755
  
  	err = phylink_of_phy_connect(mac->phylink, mac->of_node, 0);
  	if (err) {
-@@ -3157,7 +3158,10 @@ static int mtk_open(struct net_device *d
+@@ -3158,7 +3159,10 @@ static int mtk_open(struct net_device *dev)
  	if (!phy_node && eth->xgmii->regmap_sgmii[mac->id])
  		regmap_write(eth->xgmii->regmap_sgmii[mac->id], SGMSYS_QPHY_PWR_STATE_CTRL, 0);
  
@@ -94,7 +94,7 @@ index 2b21f7ed0..819d8a0be 100755
  
  	return 0;
  }
-@@ -3238,6 +3242,9 @@ static int mtk_stop(struct net_device *d
+@@ -3239,6 +3243,9 @@ static int mtk_stop(struct net_device *dev)
  
  	mtk_dma_free(eth);
  
@@ -104,7 +104,7 @@ index 2b21f7ed0..819d8a0be 100755
  	return 0;
  }
  
-@@ -3915,6 +3922,7 @@ static const struct net_device_ops mtk_n
+@@ -3918,6 +3925,7 @@ static const struct net_device_ops mtk_netdev_ops = {
  #ifdef CONFIG_NET_POLL_CONTROLLER
  	.ndo_poll_controller	= mtk_poll_controller,
  #endif
@@ -112,7 +112,7 @@ index 2b21f7ed0..819d8a0be 100755
  };
  
  static int mtk_add_mac(struct mtk_eth *eth, struct device_node *np)
-@@ -4308,6 +4316,17 @@ static int mtk_probe(struct platform_dev
+@@ -4312,6 +4320,17 @@ static int mtk_probe(struct platform_device *pdev)
  			goto err_free_dev;
  	}
  
@@ -130,7 +130,7 @@ index 2b21f7ed0..819d8a0be 100755
  	for (i = 0; i < MTK_MAX_DEVS; i++) {
  		if (!eth->netdev[i])
  			continue;
-@@ -4410,6 +4429,7 @@ static const struct mtk_soc_data mt2701_
+@@ -4414,6 +4433,7 @@ static const struct mtk_soc_data mt2701_data = {
  	.required_clks = MT7623_CLKS_BITMAP,
  	.required_pctl = true,
  	.has_sram = false,
@@ -138,7 +138,7 @@ index 2b21f7ed0..819d8a0be 100755
  	.txrx = {
  		.txd_size = sizeof(struct mtk_tx_dma),
  		.rxd_size = sizeof(struct mtk_rx_dma),
-@@ -4424,6 +4444,7 @@ static const struct mtk_soc_data mt7621_
+@@ -4428,6 +4448,7 @@ static const struct mtk_soc_data mt7621_data = {
  	.required_clks = MT7621_CLKS_BITMAP,
  	.required_pctl = false,
  	.has_sram = false,
@@ -146,7 +146,7 @@ index 2b21f7ed0..819d8a0be 100755
  	.txrx = {
  		.txd_size = sizeof(struct mtk_tx_dma),
  		.rxd_size = sizeof(struct mtk_rx_dma),
-@@ -4439,6 +4460,7 @@ static const struct mtk_soc_data mt7622_
+@@ -4443,6 +4464,7 @@ static const struct mtk_soc_data mt7622_data = {
  	.required_clks = MT7622_CLKS_BITMAP,
  	.required_pctl = false,
  	.has_sram = false,
@@ -154,7 +154,7 @@ index 2b21f7ed0..819d8a0be 100755
  	.txrx = {
  		.txd_size = sizeof(struct mtk_tx_dma),
  		.rxd_size = sizeof(struct mtk_rx_dma),
-@@ -4453,6 +4475,7 @@ static const struct mtk_soc_data mt7623_
+@@ -4457,6 +4479,7 @@ static const struct mtk_soc_data mt7623_data = {
  	.required_clks = MT7623_CLKS_BITMAP,
  	.required_pctl = true,
  	.has_sram = false,
@@ -163,7 +163,7 @@ index 2b21f7ed0..819d8a0be 100755
  		.txd_size = sizeof(struct mtk_tx_dma),
  		.rxd_size = sizeof(struct mtk_rx_dma),
 diff --git a/drivers/net/ethernet/mediatek/mtk_eth_soc.h b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
-index b6380ffeb..349f98503 100755
+index b617c13..f607307 100755
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
 @@ -15,6 +15,8 @@
@@ -175,7 +175,7 @@ index b6380ffeb..349f98503 100755
  
  #define MTK_QDMA_PAGE_SIZE	2048
  #define	MTK_MAX_RX_LENGTH	1536
-@@ -37,7 +39,8 @@
+@@ -43,7 +45,8 @@
  				 NETIF_F_HW_VLAN_CTAG_TX | \
  				 NETIF_F_SG | NETIF_F_TSO | \
  				 NETIF_F_TSO6 | \
@@ -185,15 +185,15 @@ index b6380ffeb..349f98503 100755
  #define MTK_SET_FEATURES	(NETIF_F_LRO | \
  				 NETIF_F_HW_VLAN_CTAG_RX)
  #define MTK_HW_FEATURES_MT7628	(NETIF_F_SG | NETIF_F_RXCSUM)
-@@ -107,6 +110,7 @@
- #define MTK_GDMA_TCS_EN		BIT(21)
+@@ -115,6 +118,7 @@
  #define MTK_GDMA_UCS_EN		BIT(20)
+ #define MTK_GDMA_STRP_CRC	BIT(16)
  #define MTK_GDMA_TO_PDMA	0x0
 +#define MTK_GDMA_TO_PPE		0x4444
  #define MTK_GDMA_DROP_ALL	0x7777
  
- /* Unicast Filter MAC Address Register - Low */
-@@ -547,6 +551,12 @@
+ /* GDM Egress Control Register */
+@@ -580,6 +584,12 @@
  #define RX_DMA_TCI(_x)		((_x) & (VLAN_PRIO_MASK | VLAN_VID_MASK))
  #define RX_DMA_VPID(_x)		(((_x) >> 16) & 0xffff)
  
@@ -206,15 +206,15 @@ index b6380ffeb..349f98503 100755
  /* QDMA descriptor rxd4 */
  #define RX_DMA_L4_VALID		BIT(24)
  #define RX_DMA_L4_VALID_PDMA	BIT(30)		/* when PDMA is used */
-@@ -1158,6 +1168,7 @@ struct mtk_soc_data {
- 	u32		caps;
+@@ -1438,6 +1448,7 @@ struct mtk_soc_data {
+ 	u64		caps;
  	u32		required_clks;
  	bool		required_pctl;
 +	u8		offload_version;
  	netdev_features_t hw_features;
  	bool		has_sram;
- };
-@@ -1271,6 +1282,9 @@ struct mtk_eth {
+ 	struct {
+@@ -1584,6 +1595,9 @@ struct mtk_eth {
  	int				ip_align;
  	spinlock_t			syscfg0_lock;
  	struct timer_list		mtk_dma_monitor_timer;
@@ -224,8 +224,8 @@ index b6380ffeb..349f98503 100755
  };
  
  /* struct mtk_mac -	the structure that holds the info about the MACs of the
-@@ -1319,4 +1333,8 @@ int mtk_gmac_rgmii_path_setup(struct mtk_eth *eth, int mac_id);
- void mtk_gdm_config(struct mtk_eth *eth, u32 config);
+@@ -1638,6 +1652,10 @@ int mtk_gmac_usxgmii_path_setup(struct mtk_eth *eth, int mac_id);
+ void mtk_gdm_config(struct mtk_eth *eth, u32 id, u32 config);
  void ethsys_reset(struct mtk_eth *eth, u32 reset_bits);
  
 +int mtk_eth_offload_init(struct mtk_eth *eth);
@@ -233,9 +233,11 @@ index b6380ffeb..349f98503 100755
 +		     void *type_data);
 +
  int mtk_mac2xgmii_id(struct mtk_eth *eth, int mac_id);
+ int mtk_usxgmii_init(struct mtk_xgmii *ss, struct device_node *r);
+ int mtk_xfi_pextp_init(struct mtk_xgmii *ss, struct device_node *r);
 diff --git a/drivers/net/ethernet/mediatek/mtk_ppe.c b/drivers/net/ethernet/mediatek/mtk_ppe.c
 new file mode 100644
-index 000000000..66298e223
+index 0000000..d5f70f7
 --- /dev/null
 +++ b/drivers/net/ethernet/mediatek/mtk_ppe.c
 @@ -0,0 +1,509 @@
@@ -692,12 +694,12 @@ index 000000000..66298e223
 +	      FIELD_PREP(MTK_PPE_UNBIND_AGE_DELTA, 3);
 +	ppe_w32(ppe, MTK_PPE_UNBIND_AGE, val);
 +
-+	val = FIELD_PREP(MTK_PPE_BIND_AGE0_DELTA_UDP, 12) |
++	val = FIELD_PREP(MTK_PPE_BIND_AGE0_DELTA_UDP, 30) |
 +	      FIELD_PREP(MTK_PPE_BIND_AGE0_DELTA_NON_L4, 1);
 +	ppe_w32(ppe, MTK_PPE_BIND_AGE0, val);
 +
 +	val = FIELD_PREP(MTK_PPE_BIND_AGE1_DELTA_TCP_FIN, 1) |
-+	      FIELD_PREP(MTK_PPE_BIND_AGE1_DELTA_TCP, 7);
++	      FIELD_PREP(MTK_PPE_BIND_AGE1_DELTA_TCP, 30);
 +	ppe_w32(ppe, MTK_PPE_BIND_AGE1, val);
 +
 +	val = MTK_PPE_BIND_LIMIT0_QUARTER | MTK_PPE_BIND_LIMIT0_HALF;
@@ -750,7 +752,7 @@ index 000000000..66298e223
 +}
 diff --git a/drivers/net/ethernet/mediatek/mtk_ppe.h b/drivers/net/ethernet/mediatek/mtk_ppe.h
 new file mode 100644
-index 000000000..242fb8f2a
+index 0000000..242fb8f
 --- /dev/null
 +++ b/drivers/net/ethernet/mediatek/mtk_ppe.h
 @@ -0,0 +1,288 @@
@@ -1044,7 +1046,7 @@ index 000000000..242fb8f2a
 +#endif
 diff --git a/drivers/net/ethernet/mediatek/mtk_ppe_debugfs.c b/drivers/net/ethernet/mediatek/mtk_ppe_debugfs.c
 new file mode 100644
-index 000000000..d4b482340
+index 0000000..d4b4823
 --- /dev/null
 +++ b/drivers/net/ethernet/mediatek/mtk_ppe_debugfs.c
 @@ -0,0 +1,214 @@
@@ -1264,7 +1266,7 @@ index 000000000..d4b482340
 +}
 diff --git a/drivers/net/ethernet/mediatek/mtk_ppe_offload.c b/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
 new file mode 100644
-index 000000000..4294f0c74
+index 0000000..83fc1e0
 --- /dev/null
 +++ b/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
 @@ -0,0 +1,541 @@
@@ -1811,7 +1813,7 @@ index 000000000..4294f0c74
 +}
 diff --git a/drivers/net/ethernet/mediatek/mtk_ppe_regs.h b/drivers/net/ethernet/mediatek/mtk_ppe_regs.h
 new file mode 100644
-index 000000000..0c45ea090
+index 0000000..0c45ea0
 --- /dev/null
 +++ b/drivers/net/ethernet/mediatek/mtk_ppe_regs.h
 @@ -0,0 +1,144 @@
@@ -1960,7 +1962,7 @@ index 000000000..0c45ea090
 +
 +#endif
 diff --git a/drivers/net/ppp/ppp_generic.c b/drivers/net/ppp/ppp_generic.c
-index a085213dc..813e30495 100644
+index a085213..813e304 100644
 --- a/drivers/net/ppp/ppp_generic.c
 +++ b/drivers/net/ppp/ppp_generic.c
 @@ -1378,12 +1378,34 @@ static void ppp_dev_priv_destructor(struct net_device *dev)
@@ -1999,7 +2001,7 @@ index a085213dc..813e30495 100644
  
  static struct device_type ppp_type = {
 diff --git a/drivers/net/ppp/pppoe.c b/drivers/net/ppp/pppoe.c
-index 087b01684..7a8c246ab 100644
+index 087b016..7a8c246 100644
 --- a/drivers/net/ppp/pppoe.c
 +++ b/drivers/net/ppp/pppoe.c
 @@ -974,8 +974,32 @@ static int pppoe_xmit(struct ppp_channel *chan, struct sk_buff *skb)
@@ -2036,7 +2038,7 @@ index 087b01684..7a8c246ab 100644
  
  static int pppoe_recvmsg(struct socket *sock, struct msghdr *m,
 diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
-index 38af42bf8..9f64504ac 100644
+index 38af42b..9f64504 100644
 --- a/include/linux/netdevice.h
 +++ b/include/linux/netdevice.h
 @@ -829,6 +829,59 @@ typedef u16 (*select_queue_fallback_t)(struct net_device *dev,
@@ -2135,7 +2137,7 @@ index 38af42bf8..9f64504ac 100644
  				      unsigned short mask);
  struct net_device *dev_get_by_name(struct net *net, const char *name);
 diff --git a/include/linux/ppp_channel.h b/include/linux/ppp_channel.h
-index 98966064e..91f9a9283 100644
+index 9896606..91f9a92 100644
 --- a/include/linux/ppp_channel.h
 +++ b/include/linux/ppp_channel.h
 @@ -28,6 +28,9 @@ struct ppp_channel_ops {
@@ -2149,10 +2151,10 @@ index 98966064e..91f9a9283 100644
  
  struct ppp_channel {
 diff --git a/include/net/dsa.h b/include/net/dsa.h
-index 05f66d487..cafc74218 100644
+index d29ee9e..43f65cb 100644
 --- a/include/net/dsa.h
 +++ b/include/net/dsa.h
-@@ -561,6 +561,8 @@ struct dsa_switch_ops {
+@@ -562,6 +562,8 @@ struct dsa_switch_ops {
  					  struct sk_buff *skb);
  };
  
@@ -2161,7 +2163,7 @@ index 05f66d487..cafc74218 100644
  struct dsa_switch_driver {
  	struct list_head	list;
  	const struct dsa_switch_ops *ops;
-@@ -653,6 +655,14 @@ static inline int call_dsa_notifiers(unsigned long val, struct net_device *dev,
+@@ -654,6 +656,14 @@ static inline int call_dsa_notifiers(unsigned long val, struct net_device *dev,
  #define BRCM_TAG_GET_PORT(v)		((v) >> 8)
  #define BRCM_TAG_GET_QUEUE(v)		((v) & 0xff)
  
@@ -2177,7 +2179,7 @@ index 05f66d487..cafc74218 100644
  netdev_tx_t dsa_enqueue_skb(struct sk_buff *skb, struct net_device *dev);
  int dsa_port_get_phy_strings(struct dsa_port *dp, uint8_t *data);
 diff --git a/include/net/flow_offload.h b/include/net/flow_offload.h
-index c6f7bd22d..59b873653 100644
+index c6f7bd2..59b8736 100644
 --- a/include/net/flow_offload.h
 +++ b/include/net/flow_offload.h
 @@ -138,6 +138,7 @@ enum flow_action_id {
@@ -2199,7 +2201,7 @@ index c6f7bd22d..59b873653 100644
  };
  
 diff --git a/include/net/ip6_route.h b/include/net/ip6_route.h
-index 2c739fc75..89ab8f180 100644
+index 2c739fc..89ab8f1 100644
 --- a/include/net/ip6_route.h
 +++ b/include/net/ip6_route.h
 @@ -314,12 +314,13 @@ static inline bool rt6_duplicate_nexthop(struct fib6_info *a, struct fib6_info *
@@ -2219,7 +2221,7 @@ index 2c739fc75..89ab8f180 100644
  		if (mtu)
  			goto out;
 diff --git a/include/net/netfilter/ipv6/nf_conntrack_ipv6.h b/include/net/netfilter/ipv6/nf_conntrack_ipv6.h
-index 7b3c873f8..e95483192 100644
+index 7b3c873..e954831 100644
 --- a/include/net/netfilter/ipv6/nf_conntrack_ipv6.h
 +++ b/include/net/netfilter/ipv6/nf_conntrack_ipv6.h
 @@ -4,7 +4,4 @@
@@ -2231,7 +2233,7 @@ index 7b3c873f8..e95483192 100644
 -
  #endif /* _NF_CONNTRACK_IPV6_H*/
 diff --git a/include/net/netfilter/nf_conntrack.h b/include/net/netfilter/nf_conntrack.h
-index 90690e37a..ce0bc3e62 100644
+index 90690e3..ce0bc3e 100644
 --- a/include/net/netfilter/nf_conntrack.h
 +++ b/include/net/netfilter/nf_conntrack.h
 @@ -279,6 +279,18 @@ static inline bool nf_ct_should_gc(const struct nf_conn *ct)
@@ -2254,7 +2256,7 @@ index 90690e37a..ce0bc3e62 100644
  
  int nf_conntrack_set_hashsize(const char *val, const struct kernel_param *kp);
 diff --git a/include/net/netfilter/nf_conntrack_acct.h b/include/net/netfilter/nf_conntrack_acct.h
-index f7a060c6e..7f44a7715 100644
+index f7a060c..7f44a77 100644
 --- a/include/net/netfilter/nf_conntrack_acct.h
 +++ b/include/net/netfilter/nf_conntrack_acct.h
 @@ -65,6 +65,17 @@ static inline void nf_ct_set_acct(struct net *net, bool enable)
@@ -2276,7 +2278,7 @@ index f7a060c6e..7f44a7715 100644
  
  int nf_conntrack_acct_init(void);
 diff --git a/include/net/netfilter/nf_flow_table.h b/include/net/netfilter/nf_flow_table.h
-index 68d7fc92..7cf89767 100644
+index 68d7fc9..feac793 100644
 --- a/include/net/netfilter/nf_flow_table.h
 +++ b/include/net/netfilter/nf_flow_table.h
 @@ -8,31 +8,99 @@
@@ -2416,7 +2418,7 @@ index 68d7fc92..7cf89767 100644
  	};
  };
  
-@@ -67,52 +152,139 @@ struct flow_offload_tuple_rhash {
+@@ -67,52 +152,140 @@ struct flow_offload_tuple_rhash {
  	struct flow_offload_tuple	tuple;
  };
  
@@ -2429,6 +2431,7 @@ index 68d7fc92..7cf89767 100644
 +	NF_FLOW_DNAT,
 +	NF_FLOW_TEARDOWN,
 +	NF_FLOW_HW,
++	NF_FLOW_HW_ACCT_DYING,
 +	NF_FLOW_HW_DYING,
 +	NF_FLOW_HW_DEAD,
 +	NF_FLOW_HW_PENDING,
@@ -2578,7 +2581,7 @@ index 68d7fc92..7cf89767 100644
  
  struct flow_ports {
  	__be16 source, dest;
-@@ -126,4 +298,41 @@ unsigned int nf_flow_offload_ipv6_hook(void *priv, struct sk_buff *skb,
+@@ -126,4 +299,41 @@ unsigned int nf_flow_offload_ipv6_hook(void *priv, struct sk_buff *skb,
  #define MODULE_ALIAS_NF_FLOWTABLE(family)	\
  	MODULE_ALIAS("nf-flowtable-" __stringify(family))
  
@@ -2587,7 +2590,7 @@ index 68d7fc92..7cf89767 100644
 +void nf_flow_offload_del(struct nf_flowtable *flowtable,
 +			 struct flow_offload *flow);
 +void nf_flow_offload_stats(struct nf_flowtable *flowtable,
-+			   struct flow_offload *flow);
++			   struct flow_offload *flow, bool force);
 +
 +void nf_flow_table_offload_flush(struct nf_flowtable *flowtable);
 +int nf_flow_table_offload_setup(struct nf_flowtable *flowtable,
@@ -2621,7 +2624,7 @@ index 68d7fc92..7cf89767 100644
 +
  #endif /* _NF_FLOW_TABLE_H */
 diff --git a/include/net/netns/conntrack.h b/include/net/netns/conntrack.h
-index 806454e76..9e3963c8f 100644
+index 806454e..9e3963c 100644
 --- a/include/net/netns/conntrack.h
 +++ b/include/net/netns/conntrack.h
 @@ -27,6 +27,9 @@ struct nf_tcp_net {
@@ -2645,7 +2648,7 @@ index 806454e76..9e3963c8f 100644
  
  struct nf_icmp_net {
 diff --git a/include/uapi/linux/netfilter/nf_conntrack_common.h b/include/uapi/linux/netfilter/nf_conntrack_common.h
-index 336014bf8..ae698d11c 100644
+index 336014b..ae698d1 100644
 --- a/include/uapi/linux/netfilter/nf_conntrack_common.h
 +++ b/include/uapi/linux/netfilter/nf_conntrack_common.h
 @@ -105,14 +105,19 @@ enum ip_conntrack_status {
@@ -2672,7 +2675,7 @@ index 336014bf8..ae698d11c 100644
  /* Connection tracking event types */
 diff --git a/include/uapi/linux/netfilter/xt_FLOWOFFLOAD.h b/include/uapi/linux/netfilter/xt_FLOWOFFLOAD.h
 new file mode 100644
-index 000000000..5841bbe0e
+index 0000000..5841bbe
 --- /dev/null
 +++ b/include/uapi/linux/netfilter/xt_FLOWOFFLOAD.h
 @@ -0,0 +1,17 @@
@@ -2694,7 +2697,7 @@ index 000000000..5841bbe0e
 +
 +#endif /* _XT_FLOWOFFLOAD_H */
 diff --git a/net/8021q/vlan_dev.c b/net/8021q/vlan_dev.c
-index 589615ec4..444ab5fae 100644
+index 589615e..444ab5f 100644
 --- a/net/8021q/vlan_dev.c
 +++ b/net/8021q/vlan_dev.c
 @@ -747,6 +747,26 @@ static int vlan_dev_get_iflink(const struct net_device *dev)
@@ -2733,7 +2736,7 @@ index 589615ec4..444ab5fae 100644
  
  static void vlan_dev_free(struct net_device *dev)
 diff --git a/net/bridge/br_device.c b/net/bridge/br_device.c
-index 501f77f0f..0940b44cd 100644
+index 501f77f..0940b44 100644
 --- a/net/bridge/br_device.c
 +++ b/net/bridge/br_device.c
 @@ -377,6 +377,54 @@ static int br_del_slave(struct net_device *dev, struct net_device *slave_dev)
@@ -2800,7 +2803,7 @@ index 501f77f0f..0940b44cd 100644
  
  static struct device_type br_type = {
 diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
-index a736be8a1..4bd9e9b57 100644
+index a736be8..4bd9e9b 100644
 --- a/net/bridge/br_private.h
 +++ b/net/bridge/br_private.h
 @@ -912,6 +912,13 @@ void br_vlan_port_event(struct net_bridge_port *p, unsigned long event);
@@ -2838,7 +2841,7 @@ index a736be8a1..4bd9e9b57 100644
  					const struct net_bridge *br)
  {
 diff --git a/net/bridge/br_vlan.c b/net/bridge/br_vlan.c
-index 9257292bd..bcfd16924 100644
+index 9257292..bcfd169 100644
 --- a/net/bridge/br_vlan.c
 +++ b/net/bridge/br_vlan.c
 @@ -1268,6 +1268,61 @@ int br_vlan_get_pvid_rcu(const struct net_device *dev, u16 *p_pvid)
@@ -2904,7 +2907,7 @@ index 9257292bd..bcfd16924 100644
  		     struct bridge_vlan_info *p_vinfo)
  {
 diff --git a/net/core/dev.c b/net/core/dev.c
-index fe2c856b9..4f0edb218 100644
+index 5c9dc03..87449fe 100644
 --- a/net/core/dev.c
 +++ b/net/core/dev.c
 @@ -639,6 +639,52 @@ int dev_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb)
@@ -2961,7 +2964,7 @@ index fe2c856b9..4f0edb218 100644
   *	__dev_get_by_name	- find a device by its name
   *	@net: the applicable net namespace
 diff --git a/net/dsa/dsa.c b/net/dsa/dsa.c
-index ca80f8699..35a1249a9 100644
+index ca80f86..35a1249 100644
 --- a/net/dsa/dsa.c
 +++ b/net/dsa/dsa.c
 @@ -329,6 +329,15 @@ int call_dsa_notifiers(unsigned long val, struct net_device *dev,
@@ -2981,10 +2984,10 @@ index ca80f8699..35a1249a9 100644
  {
  	int rc;
 diff --git a/net/dsa/slave.c b/net/dsa/slave.c
-index 036fda317..2dfaa1eac 100644
+index e2b91b3..2dfaa1e 100644
 --- a/net/dsa/slave.c
 +++ b/net/dsa/slave.c
-@@ -1033,14 +1031,32 @@ static int dsa_slave_setup_tc_block(struct net_device *dev,
+@@ -1031,14 +1031,32 @@ static int dsa_slave_setup_tc_block(struct net_device *dev,
  	}
  }
  
@@ -3018,7 +3021,7 @@ index 036fda317..2dfaa1eac 100644
  
  	if (!ds->ops->port_setup_tc)
  		return -EOPNOTSUPP;
-@@ -1226,6 +1242,21 @@ static struct devlink_port *dsa_slave_get_devlink_port(struct net_device *dev)
+@@ -1224,6 +1242,21 @@ static struct devlink_port *dsa_slave_get_devlink_port(struct net_device *dev)
  	return dp->ds->devlink ? &dp->devlink_port : NULL;
  }
  
@@ -3040,7 +3043,7 @@ index 036fda317..2dfaa1eac 100644
  static const struct net_device_ops dsa_slave_netdev_ops = {
  	.ndo_open	 	= dsa_slave_open,
  	.ndo_stop		= dsa_slave_close,
-@@ -1250,6 +1281,7 @@ static const struct net_device_ops dsa_slave_netdev_ops = {
+@@ -1248,6 +1281,7 @@ static const struct net_device_ops dsa_slave_netdev_ops = {
  	.ndo_vlan_rx_add_vid	= dsa_slave_vlan_rx_add_vid,
  	.ndo_vlan_rx_kill_vid	= dsa_slave_vlan_rx_kill_vid,
  	.ndo_get_devlink_port	= dsa_slave_get_devlink_port,
@@ -3048,8 +3051,7 @@ index 036fda317..2dfaa1eac 100644
  };
  
  static struct device_type dsa_type = {
-@@ -1497,7 +1529,8 @@ void dsa_slave_destroy(struct net_device *slave_dev)
- bool dsa_slave_dev_check(const struct net_device *dev)
+@@ -1499,6 +1533,7 @@ bool dsa_slave_dev_check(const struct net_device *dev)
  {
  	return dev->netdev_ops == &dsa_slave_netdev_ops;
  }
@@ -3058,7 +3060,7 @@ index 036fda317..2dfaa1eac 100644
  static int dsa_slave_changeupper(struct net_device *dev,
  				 struct netdev_notifier_changeupper_info *info)
 diff --git a/net/ipv4/netfilter/Kconfig b/net/ipv4/netfilter/Kconfig
-index f17b40211..803b92e4c 100644
+index f17b402..803b92e 100644
 --- a/net/ipv4/netfilter/Kconfig
 +++ b/net/ipv4/netfilter/Kconfig
 @@ -56,8 +56,6 @@ config NF_TABLES_ARP
@@ -3080,7 +3082,7 @@ index f17b40211..803b92e4c 100644
  	tristate "Netfilter IPv4 packet duplication to alternate destination"
  	depends on !NF_CONNTRACK || NF_CONNTRACK
 diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c
-index 5585e3a94..bb76f6061 100644
+index 5585e3a..bb76f60 100644
 --- a/net/ipv6/ip6_output.c
 +++ b/net/ipv6/ip6_output.c
 @@ -607,7 +607,7 @@ int ip6_forward(struct sk_buff *skb)
@@ -3093,7 +3095,7 @@ index 5585e3a94..bb76f6061 100644
  		mtu = IPV6_MIN_MTU;
  
 diff --git a/net/ipv6/netfilter/Kconfig b/net/ipv6/netfilter/Kconfig
-index 69443e9a3..0b481d236 100644
+index 69443e9..0b481d2 100644
 --- a/net/ipv6/netfilter/Kconfig
 +++ b/net/ipv6/netfilter/Kconfig
 @@ -45,7 +45,6 @@ config NFT_FIB_IPV6
@@ -3114,7 +3116,7 @@ index 69443e9a3..0b481d236 100644
  	tristate "Netfilter IPv6 packet duplication to alternate destination"
  	depends on !NF_CONNTRACK || NF_CONNTRACK
 diff --git a/net/ipv6/route.c b/net/ipv6/route.c
-index 98aaf0b79..2b357ac71 100644
+index da553f8..6b28946 100644
 --- a/net/ipv6/route.c
 +++ b/net/ipv6/route.c
 @@ -83,7 +83,7 @@ enum rt6_nud_state {
@@ -3154,10 +3156,10 @@ index 98aaf0b79..2b357ac71 100644
  
  /* MTU selection:
 diff --git a/net/netfilter/Kconfig b/net/netfilter/Kconfig
-index b967763f5..c040e713a 100644
+index b6e0a62..5d690ab 100644
 --- a/net/netfilter/Kconfig
 +++ b/net/netfilter/Kconfig
-@@ -690,8 +690,6 @@ config NFT_FIB_NETDEV
+@@ -689,8 +689,6 @@ config NFT_FIB_NETDEV
  
  endif # NF_TABLES_NETDEV
  
@@ -3166,7 +3168,7 @@ index b967763f5..c040e713a 100644
  config NF_FLOW_TABLE_INET
  	tristate "Netfilter flow table mixed IPv4/IPv6 module"
  	depends on NF_FLOW_TABLE
-@@ -700,11 +698,12 @@ config NF_FLOW_TABLE_INET
+@@ -699,11 +697,12 @@ config NF_FLOW_TABLE_INET
  
  	  To compile it as a module, choose M here.
  
@@ -3180,7 +3182,7 @@ index b967763f5..c040e713a 100644
  	help
  	  This option adds the flow table core infrastructure.
  
-@@ -984,6 +983,15 @@ config NETFILTER_XT_TARGET_NOTRACK
+@@ -983,6 +982,15 @@ config NETFILTER_XT_TARGET_NOTRACK
  	depends on NETFILTER_ADVANCED
  	select NETFILTER_XT_TARGET_CT
  
@@ -3197,7 +3199,7 @@ index b967763f5..c040e713a 100644
  	tristate '"RATEEST" target support'
  	depends on NETFILTER_ADVANCED
 diff --git a/net/netfilter/Makefile b/net/netfilter/Makefile
-index 4fc075b61..d93a121bc 100644
+index 4fc075b..d93a121 100644
 --- a/net/netfilter/Makefile
 +++ b/net/netfilter/Makefile
 @@ -120,7 +120,8 @@ obj-$(CONFIG_NFT_FWD_NETDEV)	+= nft_fwd_netdev.o
@@ -3219,10 +3221,10 @@ index 4fc075b61..d93a121bc 100644
  obj-$(CONFIG_NETFILTER_XT_TARGET_HMARK) += xt_HMARK.o
  obj-$(CONFIG_NETFILTER_XT_TARGET_LED) += xt_LED.o
 diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
-index f6ab6f484..f689e19d8 100644
+index f6ab6f4..f689e19 100644
 --- a/net/netfilter/nf_conntrack_core.c
 +++ b/net/netfilter/nf_conntrack_core.c
-@@ -864,9 +864,8 @@ out:
+@@ -864,9 +864,8 @@ nf_conntrack_hash_check_insert(struct nf_conn *ct)
  }
  EXPORT_SYMBOL_GPL(nf_conntrack_hash_check_insert);
  
@@ -3288,7 +3290,7 @@ index f6ab6f484..f689e19d8 100644
  	return nf_ct_delete(ct, 0, 0);
  }
 diff --git a/net/netfilter/nf_conntrack_proto_tcp.c b/net/netfilter/nf_conntrack_proto_tcp.c
-index 7204f0366..3742bae21 100644
+index 7204f03..3742bae 100644
 --- a/net/netfilter/nf_conntrack_proto_tcp.c
 +++ b/net/netfilter/nf_conntrack_proto_tcp.c
 @@ -1453,6 +1453,10 @@ void nf_conntrack_tcp_init_net(struct net *net)
@@ -3303,7 +3305,7 @@ index 7204f0366..3742bae21 100644
  
  const struct nf_conntrack_l4proto nf_conntrack_l4proto_tcp =
 diff --git a/net/netfilter/nf_conntrack_proto_udp.c b/net/netfilter/nf_conntrack_proto_udp.c
-index e3a2d018f..a1579d6c3 100644
+index e3a2d01..a1579d6 100644
 --- a/net/netfilter/nf_conntrack_proto_udp.c
 +++ b/net/netfilter/nf_conntrack_proto_udp.c
 @@ -267,6 +267,10 @@ void nf_conntrack_udp_init_net(struct net *net)
@@ -3318,7 +3320,7 @@ index e3a2d018f..a1579d6c3 100644
  
  const struct nf_conntrack_l4proto nf_conntrack_l4proto_udp =
 diff --git a/net/netfilter/nf_conntrack_standalone.c b/net/netfilter/nf_conntrack_standalone.c
-index 9c6259c28..10d9f93ce 100644
+index 9c6259c..10d9f93 100644
 --- a/net/netfilter/nf_conntrack_standalone.c
 +++ b/net/netfilter/nf_conntrack_standalone.c
 @@ -353,7 +353,9 @@ static int ct_seq_show(struct seq_file *s, void *v)
@@ -3403,7 +3405,7 @@ index 9c6259c28..10d9f93ce 100644
  	nf_conntrack_standalone_init_tcp_sysctl(net, table);
  	nf_conntrack_standalone_init_sctp_sysctl(net, table);
 diff --git a/net/netfilter/nf_flow_table_core.c b/net/netfilter/nf_flow_table_core.c
-index f212cec0..10365581 100644
+index f212cec..c3054af 100644
 --- a/net/netfilter/nf_flow_table_core.c
 +++ b/net/netfilter/nf_flow_table_core.c
 @@ -7,43 +7,21 @@
@@ -3904,7 +3906,7 @@ index f212cec0..10365581 100644
  		if (IS_ERR(tuplehash)) {
  			if (PTR_ERR(tuplehash) != -EAGAIN) {
  				err = PTR_ERR(tuplehash);
-@@ -359,23 +430,49 @@ nf_flow_table_iterate(struct nf_flowtable *flow_table,
+@@ -359,23 +430,52 @@ nf_flow_table_iterate(struct nf_flowtable *flow_table,
  
  	return err;
  }
@@ -3952,6 +3954,9 @@ index f212cec0..10365581 100644
 +
 +	if (test_bit(NF_FLOW_TEARDOWN, &flow->flags)) {
 +		if (test_bit(NF_FLOW_HW, &flow->flags)) {
++			if (!test_and_set_bit(NF_FLOW_HW_ACCT_DYING, &flow->flags))
++				nf_flow_offload_stats(flow_table, flow, true);
++
 +			if (!test_bit(NF_FLOW_HW_DYING, &flow->flags))
 +				nf_flow_offload_del(flow_table, flow);
 +			else if (test_bit(NF_FLOW_HW_DEAD, &flow->flags))
@@ -3960,12 +3965,12 @@ index f212cec0..10365581 100644
 +			flow_offload_del(flow_table, flow);
 +		}
 +	} else if (test_bit(NF_FLOW_HW, &flow->flags)) {
-+		nf_flow_offload_stats(flow_table, flow);
++		nf_flow_offload_stats(flow_table, flow, false);
 +	}
  }
  
  static void nf_flow_offload_work_gc(struct work_struct *work)
-@@ -387,30 +484,20 @@ static void nf_flow_offload_work_gc(struct work_struct *work)
+@@ -387,30 +487,20 @@ static void nf_flow_offload_work_gc(struct work_struct *work)
  	queue_delayed_work(system_power_efficient_wq, &flow_table->gc_work, HZ);
  }
  
@@ -4000,7 +4005,7 @@ index f212cec0..10365581 100644
  	udph = (void *)(skb_network_header(skb) + thoff);
  	if (udph->check || skb->ip_summed == CHECKSUM_PARTIAL) {
  		inet_proto_csum_replace2(&udph->check, skb, port,
-@@ -418,38 +505,28 @@ static int nf_flow_nat_port_udp(struct sk_buff *skb, unsigned int thoff,
+@@ -418,38 +508,28 @@ static int nf_flow_nat_port_udp(struct sk_buff *skb, unsigned int thoff,
  		if (!udph->check)
  			udph->check = CSUM_MANGLED_0;
  	}
@@ -4046,7 +4051,7 @@ index f212cec0..10365581 100644
  	hdr = (void *)(skb_network_header(skb) + thoff);
  
  	switch (dir) {
-@@ -463,25 +540,19 @@ int nf_flow_snat_port(const struct flow_offload *flow,
+@@ -463,25 +543,19 @@ int nf_flow_snat_port(const struct flow_offload *flow,
  		new_port = flow->tuplehash[FLOW_OFFLOAD_DIR_ORIGINAL].tuple.src_port;
  		hdr->dest = new_port;
  		break;
@@ -4076,7 +4081,7 @@ index f212cec0..10365581 100644
  	hdr = (void *)(skb_network_header(skb) + thoff);
  
  	switch (dir) {
-@@ -495,11 +566,9 @@ int nf_flow_dnat_port(const struct flow_offload *flow,
+@@ -495,11 +569,9 @@ int nf_flow_dnat_port(const struct flow_offload *flow,
  		new_port = flow->tuplehash[FLOW_OFFLOAD_DIR_ORIGINAL].tuple.dst_port;
  		hdr->source = new_port;
  		break;
@@ -4089,7 +4094,7 @@ index f212cec0..10365581 100644
  }
  EXPORT_SYMBOL_GPL(nf_flow_dnat_port);
  
-@@ -507,7 +576,9 @@ int nf_flow_table_init(struct nf_flowtable *flowtable)
+@@ -507,7 +579,9 @@ int nf_flow_table_init(struct nf_flowtable *flowtable)
  {
  	int err;
  
@@ -4100,7 +4105,7 @@ index f212cec0..10365581 100644
  
  	err = rhashtable_init(&flowtable->rhashtable,
  			      &nf_flow_offload_rhash_params);
-@@ -528,25 +599,24 @@ EXPORT_SYMBOL_GPL(nf_flow_table_init);
+@@ -528,25 +602,24 @@ EXPORT_SYMBOL_GPL(nf_flow_table_init);
  static void nf_flow_table_do_cleanup(struct flow_offload *flow, void *data)
  {
  	struct net_device *dev = data;
@@ -4132,7 +4137,7 @@ index f212cec0..10365581 100644
  }
  
  void nf_flow_table_cleanup(struct net_device *dev)
-@@ -555,7 +625,7 @@ void nf_flow_table_cleanup(struct net_device *dev)
+@@ -555,7 +628,7 @@ void nf_flow_table_cleanup(struct net_device *dev)
  
  	mutex_lock(&flowtable_lock);
  	list_for_each_entry(flowtable, &flowtables, list)
@@ -4141,7 +4146,7 @@ index f212cec0..10365581 100644
  	mutex_unlock(&flowtable_lock);
  }
  EXPORT_SYMBOL_GPL(nf_flow_table_cleanup);
-@@ -565,9 +635,14 @@ void nf_flow_table_free(struct nf_flowtable *flow_table)
+@@ -565,9 +638,14 @@ void nf_flow_table_free(struct nf_flowtable *flow_table)
  	mutex_lock(&flowtable_lock);
  	list_del(&flow_table->list);
  	mutex_unlock(&flowtable_lock);
@@ -4156,7 +4161,7 @@ index f212cec0..10365581 100644
  	rhashtable_destroy(&flow_table->rhashtable);
  }
  EXPORT_SYMBOL_GPL(nf_flow_table_free);
-@@ -591,12 +666,23 @@ static struct notifier_block flow_offload_netdev_notifier = {
+@@ -591,12 +669,23 @@ static struct notifier_block flow_offload_netdev_notifier = {
  
  static int __init nf_flow_table_module_init(void)
  {
@@ -4181,13 +4186,13 @@ index f212cec0..10365581 100644
  }
  
  module_init(nf_flow_table_module_init);
-@@ -604,3 +690,4 @@ module_exit(nf_flow_table_module_exit);
+@@ -604,3 +693,4 @@ module_exit(nf_flow_table_module_exit);
  
  MODULE_LICENSE("GPL");
  MODULE_AUTHOR("Pablo Neira Ayuso <pablo@netfilter.org>");
 +MODULE_DESCRIPTION("Netfilter flow table module");
 diff --git a/net/netfilter/nf_flow_table_ip.c b/net/netfilter/nf_flow_table_ip.c
-index 397129b2..6257d87c 100644
+index 397129b..6257d87 100644
 --- a/net/netfilter/nf_flow_table_ip.c
 +++ b/net/netfilter/nf_flow_table_ip.c
 @@ -7,11 +7,13 @@
@@ -4916,10 +4921,10 @@ index 397129b2..6257d87c 100644
  EXPORT_SYMBOL_GPL(nf_flow_offload_ipv6_hook);
 diff --git a/net/netfilter/nf_flow_table_offload.c b/net/netfilter/nf_flow_table_offload.c
 new file mode 100644
-index 000000000..d94c6fb92
+index 0000000..5263c1c
 --- /dev/null
 +++ b/net/netfilter/nf_flow_table_offload.c
-@@ -0,0 +1,1195 @@
+@@ -0,0 +1,1197 @@
 +#include <linux/kernel.h>
 +#include <linux/init.h>
 +#include <linux/module.h>
@@ -5957,14 +5962,16 @@ index 000000000..d94c6fb92
 +}
 +
 +void nf_flow_offload_stats(struct nf_flowtable *flowtable,
-+			   struct flow_offload *flow)
++			   struct flow_offload *flow, bool force)
 +{
 +	struct flow_offload_work *offload;
 +	__s32 delta;
 +
-+	delta = nf_flow_timeout_delta(flow->timeout);
-+	if ((delta >= (9 * flow_offload_get_timeout(flow)) / 10))
-+		return;
++	if (!force) {
++		delta = nf_flow_timeout_delta(flow->timeout);
++		if ((delta >= (9 * flow_offload_get_timeout(flow)) / 10))
++			return;
++	}
 +
 +	offload = nf_flow_offload_work_alloc(flowtable, flow, FLOW_CLS_STATS);
 +	if (!offload)
@@ -6117,10 +6124,10 @@ index 000000000..d94c6fb92
 +}
 diff --git a/net/netfilter/xt_FLOWOFFLOAD.c b/net/netfilter/xt_FLOWOFFLOAD.c
 new file mode 100644
-index 000000000..ae1eb2656
+index 0000000..489832d
 --- /dev/null
 +++ b/net/netfilter/xt_FLOWOFFLOAD.c
-@@ -0,0 +1,728 @@
+@@ -0,0 +1,785 @@
 +/*
 + * Copyright (C) 2018-2021 Felix Fietkau <nbd@nbd.name>
 + *
@@ -6505,19 +6512,28 @@ index 000000000..ae1eb2656
 +	return dev_fill_forward_path(dev, ha, stack);
 +}
 +
-+static int nf_dev_forward_path(struct nf_flow_route *route,
++static int nf_dev_forward_path(struct sk_buff *skb,
++				struct nf_flow_route *route,
 +				const struct nf_conn *ct,
 +				enum ip_conntrack_dir dir,
 +				struct net_device **devs)
 +{
 +	const struct dst_entry *dst = route->tuple[dir].dst;
++	struct ethhdr *eth = eth_hdr(skb);
 +	struct net_device_path_stack stack;
 +	struct nf_forward_info info = {};
 +	unsigned char ha[ETH_ALEN];
 +	int i;
 +
-+	if (nf_dev_fill_forward_path(route, dst, ct, dir, ha, &stack) >= 0)
++	if (nf_dev_fill_forward_path(route, dst, ct, dir, ha, &stack) >= 0) {
++		if (!(ct->status & IPS_NAT_MASK)) {
++			if (dir == IP_CT_DIR_ORIGINAL)
++				memcpy(info.h_source, eth->h_source, ETH_ALEN);
++			else if (dir == IP_CT_DIR_REPLY)
++				memcpy(info.h_source, eth->h_dest, ETH_ALEN);
++		}
 +		nf_dev_path_info(&stack, &info, ha);
++	}
 +
 +	devs[!dir] = (struct net_device *)info.indev;
 +	if (!info.indev)
@@ -6574,10 +6590,51 @@ index 000000000..ae1eb2656
 +}
 +
 +static int
-+xt_flowoffload_route(struct sk_buff *skb, const struct nf_conn *ct,
-+		     const struct xt_action_param *par,
-+		     struct nf_flow_route *route, enum ip_conntrack_dir dir,
-+		     struct net_device **devs)
++xt_flowoffload_route_nat(struct sk_buff *skb, const struct nf_conn *ct,
++			 const struct xt_action_param *par,
++			 struct nf_flow_route *route, enum ip_conntrack_dir dir,
++			 struct net_device **devs)
++{
++	struct dst_entry *this_dst = skb_dst(skb);
++	struct dst_entry *other_dst = NULL;
++	struct flowi fl;
++
++	memset(&fl, 0, sizeof(fl));
++	switch (xt_family(par)) {
++	case NFPROTO_IPV4:
++		fl.u.ip4.daddr = ct->tuplehash[dir].tuple.src.u3.ip;
++		fl.u.ip4.flowi4_oif = xt_in(par)->ifindex;
++		break;
++	case NFPROTO_IPV6:
++		fl.u.ip6.saddr = ct->tuplehash[!dir].tuple.dst.u3.in6;
++		fl.u.ip6.daddr = ct->tuplehash[dir].tuple.src.u3.in6;
++		fl.u.ip6.flowi6_oif = xt_in(par)->ifindex;
++		break;
++	}
++
++	nf_route(xt_net(par), &other_dst, &fl, false, xt_family(par));
++	if (!other_dst)
++		return -ENOENT;
++
++	nf_default_forward_path(route, this_dst, dir, devs);
++	nf_default_forward_path(route, other_dst, !dir, devs);
++
++	if (route->tuple[dir].xmit_type	== FLOW_OFFLOAD_XMIT_NEIGH &&
++	    route->tuple[!dir].xmit_type == FLOW_OFFLOAD_XMIT_NEIGH) {
++		if (nf_dev_forward_path(skb, route, ct, dir, devs))
++			return -1;
++		if (nf_dev_forward_path(skb, route, ct, !dir, devs))
++			return -1;
++	}
++
++	return 0;
++}
++
++static int
++xt_flowoffload_route_bridge(struct sk_buff *skb, const struct nf_conn *ct,
++			    const struct xt_action_param *par,
++			    struct nf_flow_route *route, enum ip_conntrack_dir dir,
++			    struct net_device **devs)
 +{
 +	int ret;
 +
@@ -6593,10 +6650,10 @@ index 000000000..ae1eb2656
 +	if (ret)
 +		goto err_route_dir1;
 +
-+	if (route->tuple[dir].xmit_type	== FLOW_OFFLOAD_XMIT_NEIGH &&
++	if (route->tuple[dir].xmit_type == FLOW_OFFLOAD_XMIT_NEIGH &&
 +	    route->tuple[!dir].xmit_type == FLOW_OFFLOAD_XMIT_NEIGH) {
-+		if (nf_dev_forward_path(route, ct, dir, devs) ||
-+		    nf_dev_forward_path(route, ct, !dir, devs)) {
++		if (nf_dev_forward_path(skb, route, ct, dir, devs) ||
++		    nf_dev_forward_path(skb, route, ct, !dir, devs)) {
 +			ret = -1;
 +			goto err_route_dir2;
 +		}
@@ -6666,8 +6723,13 @@ index 000000000..ae1eb2656
 +
 +	dir = CTINFO2DIR(ctinfo);
 +
-+	if (xt_flowoffload_route(skb, ct, par, &route, dir, devs) < 0)
-+		goto err_flow_route;
++	if (ct->status & IPS_NAT_MASK) {
++		if (xt_flowoffload_route_nat(skb, ct, par, &route, dir, devs) < 0)
++			goto err_flow_route;
++	} else {
++		if (xt_flowoffload_route_bridge(skb, ct, par, &route, dir, devs) < 0)
++			goto err_flow_route;
++	}
 +
 +	flow = flow_offload_alloc(ct);
 +	if (!flow)
@@ -6693,7 +6755,8 @@ index 000000000..ae1eb2656
 +	xt_flowoffload_check_device(table, devs[0]);
 +	xt_flowoffload_check_device(table, devs[1]);
 +
-+	dst_release(route.tuple[dir].dst);
++	if (!(ct->status & IPS_NAT_MASK))
++		dst_release(route.tuple[dir].dst);
 +	dst_release(route.tuple[!dir].dst);
 +
 +	return XT_CONTINUE;
@@ -6701,7 +6764,8 @@ index 000000000..ae1eb2656
 +err_flow_add:
 +	flow_offload_free(flow);
 +err_flow_alloc:
-+	dst_release(route.tuple[dir].dst);
++	if (!(ct->status & IPS_NAT_MASK))
++		dst_release(route.tuple[dir].dst);
 +	dst_release(route.tuple[!dir].dst);
 +err_flow_route:
 +	clear_bit(IPS_OFFLOAD_BIT, &ct->status);
diff --git a/openwrt/target/linux/mediatek/patches-5.4/9999-2-flow-offload-add-mtkhnat-flow-accounting.patch b/openwrt/target/linux/mediatek/patches-5.4/9999-2-flow-offload-add-mtkhnat-flow-accounting.patch
index 1a5c255..8d7ec89 100644
--- a/openwrt/target/linux/mediatek/patches-5.4/9999-2-flow-offload-add-mtkhnat-flow-accounting.patch
+++ b/openwrt/target/linux/mediatek/patches-5.4/9999-2-flow-offload-add-mtkhnat-flow-accounting.patch
@@ -1,8 +1,24 @@
+From 23c21db36b55ae1fe2f9b2a2b44f59d9cbe09f5d Mon Sep 17 00:00:00 2001
+From: mtk27745 <rex.lu@mediatek.com>
+Date: Thu, 13 Apr 2023 20:13:34 +0800
+Subject: [PATCH] 9999-2-flow-offload-add-mtkhnat-flow-accounting.patch
+
+---
+ drivers/net/ethernet/mediatek/mtk_eth_soc.c   |  11 +-
+ drivers/net/ethernet/mediatek/mtk_eth_soc.h   |   1 +
+ drivers/net/ethernet/mediatek/mtk_ppe.c       | 131 +++++++++++++++++-
+ drivers/net/ethernet/mediatek/mtk_ppe.h       |  23 ++-
+ .../net/ethernet/mediatek/mtk_ppe_debugfs.c   |  10 +-
+ .../net/ethernet/mediatek/mtk_ppe_offload.c   |   7 +
+ drivers/net/ethernet/mediatek/mtk_ppe_regs.h  |  14 ++
+ net/netfilter/xt_FLOWOFFLOAD.c                |   2 +-
+ 8 files changed, 191 insertions(+), 8 deletions(-)
+
 diff --git a/drivers/net/ethernet/mediatek/mtk_eth_soc.c b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-index 4f53794..dc5d050 100644
+index a48ba115a..babaa0eda 100644
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-@@ -3944,7 +3944,8 @@ static int mtk_probe(struct platform_device *pdev)
+@@ -4452,7 +4452,8 @@ static int mtk_probe(struct platform_device *pdev)
  		for (i = 0; i < eth->ppe_num; i++) {
  			eth->ppe[i] = mtk_ppe_init(eth,
  						   eth->base + MTK_ETH_PPE_BASE + i * 0x400,
@@ -12,7 +28,7 @@ index 4f53794..dc5d050 100644
  			if (!eth->ppe[i]) {
  				err = -ENOMEM;
  				goto err_free_dev;
-@@ -4057,6 +4058,7 @@ static const struct mtk_soc_data mt2701_data = {
+@@ -4568,6 +4569,7 @@ static const struct mtk_soc_data mt2701_data = {
  	.required_clks = MT7623_CLKS_BITMAP,
  	.required_pctl = true,
  	.has_sram = false,
@@ -20,7 +36,7 @@ index 4f53794..dc5d050 100644
  	.hash_way = 2,
  	.offload_version = 2,
  	.txrx = {
-@@ -4073,6 +4075,7 @@ static const struct mtk_soc_data mt7621_data = {
+@@ -4584,6 +4586,7 @@ static const struct mtk_soc_data mt7621_data = {
  	.required_clks = MT7621_CLKS_BITMAP,
  	.required_pctl = false,
  	.has_sram = false,
@@ -28,7 +44,7 @@ index 4f53794..dc5d050 100644
  	.hash_way = 2,
  	.offload_version = 2,
  	.txrx = {
-@@ -4090,6 +4093,7 @@ static const struct mtk_soc_data mt7622_data = {
+@@ -4601,6 +4604,7 @@ static const struct mtk_soc_data mt7622_data = {
  	.required_clks = MT7622_CLKS_BITMAP,
  	.required_pctl = false,
  	.has_sram = false,
@@ -36,7 +52,7 @@ index 4f53794..dc5d050 100644
  	.hash_way = 2,
  	.offload_version = 2,
  	.txrx = {
-@@ -4106,6 +4110,7 @@ static const struct mtk_soc_data mt7623_data = {
+@@ -4617,6 +4621,7 @@ static const struct mtk_soc_data mt7623_data = {
  	.required_clks = MT7623_CLKS_BITMAP,
  	.required_pctl = true,
  	.has_sram = false,
@@ -44,7 +60,7 @@ index 4f53794..dc5d050 100644
  	.hash_way = 2,
  	.offload_version = 2,
  	.txrx = {
-@@ -4123,6 +4128,7 @@ static const struct mtk_soc_data mt7629_data = {
+@@ -4634,6 +4639,7 @@ static const struct mtk_soc_data mt7629_data = {
  	.required_clks = MT7629_CLKS_BITMAP,
  	.required_pctl = false,
  	.has_sram = false,
@@ -52,7 +68,7 @@ index 4f53794..dc5d050 100644
  	.txrx = {
  		.txd_size = sizeof(struct mtk_tx_dma),
  		.rxd_size = sizeof(struct mtk_rx_dma),
-@@ -4138,6 +4144,7 @@ static const struct mtk_soc_data mt7986_data = {
+@@ -4649,6 +4655,7 @@ static const struct mtk_soc_data mt7986_data = {
  	.required_clks = MT7986_CLKS_BITMAP,
  	.required_pctl = false,
  	.has_sram = true,
@@ -60,7 +76,7 @@ index 4f53794..dc5d050 100644
  	.hash_way = 4,
  	.offload_version = 2,
  	.txrx = {
-@@ -4155,6 +4162,7 @@ static const struct mtk_soc_data mt7981_data = {
+@@ -4666,6 +4673,7 @@ static const struct mtk_soc_data mt7981_data = {
  	.required_clks = MT7981_CLKS_BITMAP,
  	.required_pctl = false,
  	.has_sram = true,
@@ -68,7 +84,7 @@ index 4f53794..dc5d050 100644
  	.hash_way = 4,
  	.offload_version = 2,
  	.txrx = {
-@@ -4171,6 +4179,7 @@ static const struct mtk_soc_data rt5350_data = {
+@@ -4697,6 +4705,7 @@ static const struct mtk_soc_data rt5350_data = {
  	.required_clks = MT7628_CLKS_BITMAP,
  	.required_pctl = false,
  	.has_sram = false,
@@ -77,10 +93,10 @@ index 4f53794..dc5d050 100644
  		.txd_size = sizeof(struct mtk_tx_dma),
  		.rxd_size = sizeof(struct mtk_rx_dma),
 diff --git a/drivers/net/ethernet/mediatek/mtk_eth_soc.h b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
-index f659633..5e16fa8 100644
+index 4dd3ca356..f886876a9 100644
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
-@@ -1213,6 +1213,7 @@ struct mtk_soc_data {
+@@ -1476,6 +1476,7 @@ struct mtk_soc_data {
  	u8		offload_version;
  	netdev_features_t hw_features;
  	bool		has_sram;
@@ -89,7 +105,7 @@ index f659633..5e16fa8 100644
  		u32	txd_size;
  		u32	rxd_size;
 diff --git a/drivers/net/ethernet/mediatek/mtk_ppe.c b/drivers/net/ethernet/mediatek/mtk_ppe.c
-index 918aa22..8c036cd 100755
+index efb32d142..84b9456b5 100755
 --- a/drivers/net/ethernet/mediatek/mtk_ppe.c
 +++ b/drivers/net/ethernet/mediatek/mtk_ppe.c
 @@ -74,6 +74,46 @@ static int mtk_ppe_wait_busy(struct mtk_ppe *ppe)
@@ -139,22 +155,26 @@ index 918aa22..8c036cd 100755
  static void mtk_ppe_cache_clear(struct mtk_ppe *ppe)
  {
  	ppe_set(ppe, MTK_PPE_CACHE_CTL, MTK_PPE_CACHE_CTL_CLEAR);
-@@ -412,6 +452,14 @@ __mtk_foe_entry_clear(struct mtk_ppe *ppe, struct mtk_flow_entry *entry)
+@@ -425,6 +465,18 @@ __mtk_foe_entry_clear(struct mtk_ppe *ppe, struct mtk_flow_entry *entry)
+ 		ppe->foe_table[entry->hash].ib1 |= FIELD_PREP(MTK_FOE_IB1_STATE,
  							      MTK_FOE_STATE_INVALID);
  		dma_wmb();
 +
 +		if (ppe->accounting) {
-+			struct mtk_foe_accounting *acct;
++			struct mtk_foe_accounting *acct, *acct_updated;
 +
 +			acct = ppe->acct_table + entry->hash * sizeof(*acct);
 +			acct->packets = 0;
 +			acct->bytes = 0;
++
++			acct_updated = ppe->acct_updated_table + entry->hash * sizeof(*acct_updated);
++			acct_updated->packets = 0;
++			acct_updated->bytes = 0;
 +		}
-	}
+ 	}
  	entry->hash = 0xffff;
  
- 	if (entry->type != MTK_FLOW_TYPE_L2_SUBFLOW)
-@@ -513,6 +560,16 @@ __mtk_foe_entry_commit(struct mtk_ppe *ppe, struct mtk_foe_entry *entry,
+@@ -527,6 +579,16 @@ __mtk_foe_entry_commit(struct mtk_ppe *ppe, struct mtk_foe_entry *entry,
  	wmb();
  	hwe->ib1 = entry->ib1;
  
@@ -171,7 +191,7 @@ index 918aa22..8c036cd 100755
  	dma_wmb();
  
  	mtk_ppe_cache_clear(ppe);
-@@ -618,8 +675,6 @@ void __mtk_ppe_check_skb(struct mtk_ppe *ppe, struct sk_buff *skb, u16 hash)
+@@ -636,8 +698,6 @@ void __mtk_ppe_check_skb(struct mtk_ppe *ppe, struct sk_buff *skb, u16 hash)
  		}
  
  		if (found || !mtk_flow_entry_match(entry, hwe)) {
@@ -180,14 +200,14 @@ index 918aa22..8c036cd 100755
  			continue;
  		}
  
-@@ -676,12 +731,40 @@ int mtk_foe_entry_idle_time(struct mtk_ppe *ppe, struct mtk_flow_entry *entry)
+@@ -694,12 +754,44 @@ int mtk_foe_entry_idle_time(struct mtk_ppe *ppe, struct mtk_flow_entry *entry)
  	return __mtk_foe_entry_idle_time(ppe, entry->data.ib1);
  }
  
 -struct mtk_ppe *mtk_ppe_init(struct mtk_eth *eth, void __iomem *base, int version, int way, int id)
 +struct mtk_foe_accounting *mtk_foe_entry_get_mib(struct mtk_ppe *ppe, u32 index, struct mtk_foe_accounting *diff)
 +{
-+	struct mtk_foe_accounting *acct;
++	struct mtk_foe_accounting *acct, *acct_updated;
 +	int size = sizeof(struct mtk_foe_accounting);
 +	u64 bytes, packets;
 +
@@ -203,8 +223,12 @@ index 918aa22..8c036cd 100755
 +	acct->packets += packets;
 +
 +	if (diff) {
-+		diff->bytes = bytes;
-+		diff->packets = packets;
++		acct_updated = ppe->acct_updated_table + index * size;
++
++		diff->bytes = acct->bytes - acct_updated->bytes;
++		diff->packets = acct->packets - acct_updated->packets;
++		acct_updated->bytes += diff->bytes;
++		acct_updated->packets += diff->packets;
 +	}
 +
 +	return acct;
@@ -218,11 +242,11 @@ index 918aa22..8c036cd 100755
 +	struct mtk_mib_entry *mib;
  	struct mtk_ppe *ppe;
  	struct hlist_head *flow;
-+	struct mtk_foe_accounting *acct;
++	struct mtk_foe_accounting *acct, *acct_updated;
  
  	ppe = devm_kzalloc(dev, sizeof(*ppe), GFP_KERNEL);
  	if (!ppe)
-@@ -698,6 +781,7 @@ struct mtk_ppe *mtk_ppe_init(struct mtk_eth *eth, void __iomem *base, int versio
+@@ -716,6 +808,7 @@ struct mtk_ppe *mtk_ppe_init(struct mtk_eth *eth, void __iomem *base, int versio
  	ppe->version = version;
  	ppe->way = way;
  	ppe->id = id;
@@ -230,7 +254,7 @@ index 918aa22..8c036cd 100755
  
  	foe = dmam_alloc_coherent(ppe->dev, MTK_PPE_ENTRIES * sizeof(*foe),
  				  &ppe->foe_phys, GFP_KERNEL);
-@@ -713,6 +797,24 @@ struct mtk_ppe *mtk_ppe_init(struct mtk_eth *eth, void __iomem *base, int versio
+@@ -731,6 +824,31 @@ struct mtk_ppe *mtk_ppe_init(struct mtk_eth *eth, void __iomem *base, int versio
  
  	ppe->foe_flow = flow;
  
@@ -250,14 +274,21 @@ index 918aa22..8c036cd 100755
 +			return NULL;
 +
 +		ppe->acct_table = acct;
++
++		acct_updated = devm_kzalloc(dev, MTK_PPE_ENTRIES * sizeof(*acct_updated),
++					    GFP_KERNEL);
++		if (!acct_updated)
++			return NULL;
++
++		ppe->acct_updated_table = acct_updated;
 +	}
 +
  	return ppe;
  }
  
-@@ -811,6 +949,13 @@ int mtk_ppe_start(struct mtk_ppe *ppe)
- 	ppe_w32(ppe, MTK_PPE_DEFAULT_CPU_PORT1, 0xcb777);
+@@ -832,6 +950,13 @@ int mtk_ppe_start(struct mtk_ppe *ppe)
  	ppe_w32(ppe, MTK_PPE_SBW_CTRL, 0x7f);
+ #endif
  
 +	if (ppe->accounting && ppe->mib_phys) {
 +		ppe_w32(ppe, MTK_PPE_MIB_TB_BASE, ppe->mib_phys);
@@ -270,10 +301,10 @@ index 918aa22..8c036cd 100755
  }
  
 diff --git a/drivers/net/ethernet/mediatek/mtk_ppe.h b/drivers/net/ethernet/mediatek/mtk_ppe.h
-index 3d6928c..8076e5d 100644
+index feb1a4a2a..86288b0e6 100644
 --- a/drivers/net/ethernet/mediatek/mtk_ppe.h
 +++ b/drivers/net/ethernet/mediatek/mtk_ppe.h
-@@ -270,6 +270,20 @@ struct mtk_flow_entry {
+@@ -316,6 +316,20 @@ struct mtk_flow_entry {
  	unsigned long cookie;
  };
  
@@ -294,7 +325,7 @@ index 3d6928c..8076e5d 100644
  struct mtk_ppe {
  	struct mtk_eth *eth;
  	struct device *dev;
-@@ -277,10 +291,14 @@ struct mtk_ppe {
+@@ -323,19 +337,25 @@ struct mtk_ppe {
  	int version;
  	int id;
  	int way;
@@ -309,8 +340,10 @@ index 3d6928c..8076e5d 100644
  	u16 foe_check_time[MTK_PPE_ENTRIES];
  	struct hlist_head *foe_flow;
  
-@@ -289,7 +307,8 @@ struct mtk_ppe {
+ 	struct rhashtable l2_flows;
+ 
  	void *acct_table;
++	void *acct_updated_table;
  };
  
 -struct mtk_ppe *mtk_ppe_init(struct mtk_eth *eth, void __iomem *base, int version, int way, int id);
@@ -319,7 +352,7 @@ index 3d6928c..8076e5d 100644
  int mtk_ppe_start(struct mtk_ppe *ppe);
  int mtk_ppe_stop(struct mtk_ppe *ppe);
  
-@@ -340,5 +359,6 @@ int mtk_foe_entry_set_wdma(struct mtk_foe_entry *entry, int wdma_idx, int txq,
+@@ -386,5 +406,6 @@ int mtk_foe_entry_set_wdma(struct mtk_foe_entry *entry, int wdma_idx, int txq,
  int mtk_foe_entry_commit(struct mtk_ppe *ppe, struct mtk_flow_entry *entry);
  void mtk_foe_entry_clear(struct mtk_ppe *ppe, struct mtk_flow_entry *entry);
  int mtk_foe_entry_idle_time(struct mtk_ppe *ppe, struct mtk_flow_entry *entry);
@@ -327,7 +360,7 @@ index 3d6928c..8076e5d 100644
  
  #endif
 diff --git a/drivers/net/ethernet/mediatek/mtk_ppe_debugfs.c b/drivers/net/ethernet/mediatek/mtk_ppe_debugfs.c
-index f4ebe59..d713e2e 100644
+index f4ebe5944..d713e2e6f 100644
 --- a/drivers/net/ethernet/mediatek/mtk_ppe_debugfs.c
 +++ b/drivers/net/ethernet/mediatek/mtk_ppe_debugfs.c
 @@ -81,6 +81,7 @@ mtk_ppe_debugfs_foe_show(struct seq_file *m, struct mtk_ppe *ppe, bool bind)
@@ -363,10 +396,10 @@ index f4ebe59..d713e2e 100644
  
  	return 0;
 diff --git a/drivers/net/ethernet/mediatek/mtk_ppe_offload.c b/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
-index 2f7d76d..f258539 100755
+index 039a47c59..05b5558e7 100755
 --- a/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
 +++ b/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
-@@ -504,6 +504,7 @@ static int
+@@ -509,6 +509,7 @@ static int
  mtk_flow_offload_stats(struct mtk_eth *eth, struct flow_cls_offload *f)
  {
  	struct mtk_flow_entry *entry;
@@ -374,7 +407,7 @@ index 2f7d76d..f258539 100755
  	u32 idle;
  	int i;
  
-@@ -516,6 +517,12 @@ mtk_flow_offload_stats(struct mtk_eth *eth, struct flow_cls_offload *f)
+@@ -521,6 +522,12 @@ mtk_flow_offload_stats(struct mtk_eth *eth, struct flow_cls_offload *f)
  	idle = mtk_foe_entry_idle_time(eth->ppe[i], entry);
  	f->stats.lastused = jiffies - idle * HZ;
  
@@ -388,10 +421,10 @@ index 2f7d76d..f258539 100755
  }
  
 diff --git a/drivers/net/ethernet/mediatek/mtk_ppe_regs.h b/drivers/net/ethernet/mediatek/mtk_ppe_regs.h
-index d319f18..9eb7a0d 100644
+index d319f1861..8d3ebe1d6 100644
 --- a/drivers/net/ethernet/mediatek/mtk_ppe_regs.h
 +++ b/drivers/net/ethernet/mediatek/mtk_ppe_regs.h
-@@ -145,6 +146,20 @@ enum {
+@@ -145,6 +145,20 @@ enum {
  
  #define MTK_PPE_MIB_TB_BASE			0x338
  
@@ -413,10 +446,10 @@ index d319f18..9eb7a0d 100644
  #define MTK_PPE_MIB_CACHE_CTL_EN		BIT(0)
  #define MTK_PPE_MIB_CACHE_CTL_FLUSH		BIT(2)
 diff --git a/net/netfilter/xt_FLOWOFFLOAD.c b/net/netfilter/xt_FLOWOFFLOAD.c
-index 8547f4a..c175e4d 100644
+index 8547f4a48..616c76fed 100644
 --- a/net/netfilter/xt_FLOWOFFLOAD.c
 +++ b/net/netfilter/xt_FLOWOFFLOAD.c
-@@ -700,12 +781,12 @@ static int __init xt_flowoffload_tg_init(void)
+@@ -700,7 +700,7 @@ static int __init xt_flowoffload_tg_init(void)
  	if (ret)
  		goto cleanup;
  
@@ -425,8 +458,6 @@ index 8547f4a..c175e4d 100644
  
  	ret = xt_register_target(&offload_tg_reg);
  	if (ret)
- 		goto cleanup2;
- 
- 	return 0;
- 
- cleanup2:
+-- 
+2.18.0
+
diff --git a/openwrt/target/linux/mediatek/patches-5.4/9999-3-flow-offload-add-mtkhnat-qdma-qos.patch b/openwrt/target/linux/mediatek/patches-5.4/9999-3-flow-offload-add-mtkhnat-qdma-qos.patch
index e6d8691..d61813e 100644
--- a/openwrt/target/linux/mediatek/patches-5.4/9999-3-flow-offload-add-mtkhnat-qdma-qos.patch
+++ b/openwrt/target/linux/mediatek/patches-5.4/9999-3-flow-offload-add-mtkhnat-qdma-qos.patch
@@ -1,5 +1,23 @@
+From ed6156e2f9ac2219aa84885162130ed57f9b7bed Mon Sep 17 00:00:00 2001
+From: mtk27745 <rex.lu@mediatek.com>
+Date: Thu, 13 Apr 2023 20:14:14 +0800
+Subject: [PATCH] 9999-3-flow-offload-add-mtkhnat-qdma-qos.patch
+
+---
+ drivers/net/ethernet/mediatek/Makefile        |   2 +-
+ drivers/net/ethernet/mediatek/mtk_eth_soc.c   |   9 +
+ drivers/net/ethernet/mediatek/mtk_eth_soc.h   |  35 +-
+ drivers/net/ethernet/mediatek/mtk_ppe.c       |  10 +
+ drivers/net/ethernet/mediatek/mtk_ppe.h       |   1 +
+ .../net/ethernet/mediatek/mtk_ppe_offload.c   |  11 +-
+ .../net/ethernet/mediatek/mtk_qdma_debugfs.c  | 435 ++++++++++++++++++
+ include/net/flow_offload.h                    |   1 +
+ net/netfilter/nf_flow_table_offload.c         |   4 +-
+ 9 files changed, 503 insertions(+), 5 deletions(-)
+ create mode 100644 drivers/net/ethernet/mediatek/mtk_qdma_debugfs.c
+
 diff --git a/drivers/net/ethernet/mediatek/Makefile b/drivers/net/ethernet/mediatek/Makefile
-index 0c724a5..93cd55f 100644
+index 498c002ed..ec3b30585 100644
 --- a/drivers/net/ethernet/mediatek/Makefile
 +++ b/drivers/net/ethernet/mediatek/Makefile
 @@ -5,7 +5,7 @@
@@ -12,10 +30,10 @@ index 0c724a5..93cd55f 100644
  ifdef CONFIG_DEBUG_FS
  mtk_eth-$(CONFIG_NET_MEDIATEK_SOC_WED) += mtk_wed_debugfs.o
 diff --git a/drivers/net/ethernet/mediatek/mtk_eth_soc.c b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-index efdd2e6..9ffc46b 100644
+index babaa0eda..b2653286c 100644
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-@@ -3992,6 +3992,8 @@ static int mtk_probe(struct platform_device *pdev)
+@@ -4465,6 +4465,8 @@ static int mtk_probe(struct platform_device *pdev)
  		}
  
  		mtk_ppe_debugfs_init(eth);
@@ -24,7 +42,7 @@ index efdd2e6..9ffc46b 100644
  	}
  
  	for (i = 0; i < MTK_MAX_DEVS; i++) {
-@@ -4101,6 +4103,7 @@ static const struct mtk_soc_data mt2701_data = {
+@@ -4577,6 +4579,7 @@ static const struct mtk_soc_data mt2701_data = {
  		.rxd_size = sizeof(struct mtk_rx_dma),
  		.dma_max_len = MTK_TX_DMA_BUF_LEN,
  		.dma_len_offset = MTK_TX_DMA_BUF_SHIFT,
@@ -32,7 +50,7 @@ index efdd2e6..9ffc46b 100644
  	},
  };
  
-@@ -4118,6 +4121,7 @@ static const struct mtk_soc_data mt7621_data = {
+@@ -4594,6 +4597,7 @@ static const struct mtk_soc_data mt7621_data = {
  		.rxd_size = sizeof(struct mtk_rx_dma),
  		.dma_max_len = MTK_TX_DMA_BUF_LEN,
  		.dma_len_offset = MTK_TX_DMA_BUF_SHIFT,
@@ -40,7 +58,7 @@ index efdd2e6..9ffc46b 100644
  	},
  };
  
-@@ -4136,6 +4140,7 @@ static const struct mtk_soc_data mt7622_data = {
+@@ -4612,6 +4616,7 @@ static const struct mtk_soc_data mt7622_data = {
  		.rxd_size = sizeof(struct mtk_rx_dma),
  		.dma_max_len = MTK_TX_DMA_BUF_LEN,
  		.dma_len_offset = MTK_TX_DMA_BUF_SHIFT,
@@ -48,7 +66,7 @@ index efdd2e6..9ffc46b 100644
  	},
  };
  
-@@ -4153,6 +4158,7 @@ static const struct mtk_soc_data mt7623_data = {
+@@ -4629,6 +4634,7 @@ static const struct mtk_soc_data mt7623_data = {
  		.rxd_size = sizeof(struct mtk_rx_dma),
  		.dma_max_len = MTK_TX_DMA_BUF_LEN,
  		.dma_len_offset = MTK_TX_DMA_BUF_SHIFT,
@@ -56,7 +74,7 @@ index efdd2e6..9ffc46b 100644
  	},
  };
  
-@@ -4187,6 +4193,7 @@ static const struct mtk_soc_data mt7986_data = {
+@@ -4663,6 +4669,7 @@ static const struct mtk_soc_data mt7986_data = {
  		.rxd_size = sizeof(struct mtk_rx_dma_v2),
  		.dma_max_len = MTK_TX_DMA_BUF_LEN_V2,
  		.dma_len_offset = MTK_TX_DMA_BUF_SHIFT_V2,
@@ -64,7 +82,7 @@ index efdd2e6..9ffc46b 100644
  	},
  };
  
-@@ -4205,6 +4212,7 @@ static const struct mtk_soc_data mt7981_data = {
+@@ -4681,6 +4688,7 @@ static const struct mtk_soc_data mt7981_data = {
  		.rxd_size = sizeof(struct mtk_rx_dma_v2),
  		.dma_max_len = MTK_TX_DMA_BUF_LEN_V2,
  		.dma_len_offset = MTK_TX_DMA_BUF_SHIFT_V2,
@@ -72,7 +90,7 @@ index efdd2e6..9ffc46b 100644
  	},
  };
  
-@@ -4220,6 +4228,7 @@ static const struct mtk_soc_data rt5350_data = {
+@@ -4711,6 +4719,7 @@ static const struct mtk_soc_data rt5350_data = {
  		.rxd_size = sizeof(struct mtk_rx_dma),
  		.dma_max_len = MTK_TX_DMA_BUF_LEN,
  		.dma_len_offset = MTK_TX_DMA_BUF_SHIFT,
@@ -81,10 +99,10 @@ index efdd2e6..9ffc46b 100644
  };
  
 diff --git a/drivers/net/ethernet/mediatek/mtk_eth_soc.h b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
-index c87a823..955bb27 100644
+index f886876a9..2ee6792c9 100644
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
-@@ -352,10 +352,21 @@
+@@ -382,10 +382,21 @@
  
  /* QDMA TX Queue Configuration Registers */
  #define MTK_QTX_CFG(x)		(QDMA_BASE + (x * 0x10))
@@ -106,7 +124,7 @@ index c87a823..955bb27 100644
  
  /* QDMA RX Base Pointer Register */
  #define MTK_QRX_BASE_PTR0	(QDMA_BASE + 0x100)
-@@ -373,7 +384,9 @@
+@@ -403,7 +414,9 @@
  #define MTK_QRX_DRX_IDX0	(QDMA_BASE + 0x10c)
  
  /* QDMA Page Configuration Register */
@@ -117,7 +135,7 @@ index c87a823..955bb27 100644
  
  /* QDMA Global Configuration Register */
  #define MTK_QDMA_GLO_CFG	(QDMA_BASE + 0x204)
-@@ -410,6 +423,9 @@
+@@ -440,6 +453,9 @@
  #define FC_THRES_DROP_EN	(7 << 16)
  #define FC_THRES_MIN		0x4444
  
@@ -126,8 +144,8 @@ index c87a823..955bb27 100644
 +
  /* QDMA Interrupt Status Register */
  #define MTK_QDMA_INT_STATUS	(QDMA_BASE + 0x218)
- #if defined(CONFIG_MEDIATEK_NETSYS_V2)
-@@ -444,6 +460,11 @@
+ #if defined(CONFIG_MEDIATEK_NETSYS_V2) || defined(CONFIG_MEDIATEK_NETSYS_V3)
+@@ -475,6 +491,11 @@
  /* QDMA Interrupt Mask Register */
  #define MTK_QDMA_HRED2		(QDMA_BASE + 0x244)
  
@@ -139,7 +157,7 @@ index c87a823..955bb27 100644
  /* QDMA TX Forward CPU Pointer Register */
  #define MTK_QTX_CTX_PTR		(QDMA_BASE +0x300)
  
-@@ -471,6 +492,14 @@
+@@ -502,6 +523,14 @@
  /* QDMA FQ Free Page Buffer Length Register */
  #define MTK_QDMA_FQ_BLEN	(QDMA_BASE +0x32c)
  
@@ -154,7 +172,7 @@ index c87a823..955bb27 100644
  /* WDMA Registers */
  #define MTK_WDMA_DTX_PTR(x)	(WDMA_BASE(x) + 0xC)
  #define MTK_WDMA_GLO_CFG(x)	(WDMA_BASE(x) + 0x204)
-@@ -1223,6 +1252,7 @@ struct mtk_soc_data {
+@@ -1482,6 +1511,7 @@ struct mtk_soc_data {
  		u32	rxd_size;
  		u32	dma_max_len;
  		u32	dma_len_offset;
@@ -162,7 +180,7 @@ index c87a823..955bb27 100644
  	} txrx;
  };
  
-@@ -1353,6 +1383,7 @@ struct mtk_eth {
+@@ -1624,6 +1654,7 @@ struct mtk_eth {
  	spinlock_t			syscfg0_lock;
  	struct timer_list		mtk_dma_monitor_timer;
  
@@ -170,18 +188,20 @@ index c87a823..955bb27 100644
  	u8				ppe_num;
  	struct mtk_ppe			*ppe[MTK_MAX_PPE_NUM];
  	struct rhashtable		flow_table;
-@@ -1412,4 +1443,6 @@ void mtk_eth_set_dma_device(struct mtk_eth *eth, struct device *dma_dev);
+@@ -1688,6 +1719,8 @@ void mtk_eth_set_dma_device(struct mtk_eth *eth, struct device *dma_dev);
  
  int mtk_ppe_debugfs_init(struct mtk_eth *eth);
  
 +int mtk_qdma_debugfs_init(struct mtk_eth *eth);
 +
  int mtk_mac2xgmii_id(struct mtk_eth *eth, int mac_id);
+ int mtk_usxgmii_init(struct mtk_xgmii *ss, struct device_node *r);
+ int mtk_xfi_pextp_init(struct mtk_xgmii *ss, struct device_node *r);
 diff --git a/drivers/net/ethernet/mediatek/mtk_ppe.c b/drivers/net/ethernet/mediatek/mtk_ppe.c
-index a49275f..1767823 100755
+index 84b9456b5..df54d2a74 100755
 --- a/drivers/net/ethernet/mediatek/mtk_ppe.c
 +++ b/drivers/net/ethernet/mediatek/mtk_ppe.c
-@@ -406,6 +406,16 @@ int mtk_foe_entry_set_wdma(struct mtk_foe_entry *entry, int wdma_idx, int txq,
+@@ -420,6 +420,16 @@ int mtk_foe_entry_set_wdma(struct mtk_foe_entry *entry, int wdma_idx, int txq,
  	return 0;
  }
  
@@ -199,10 +219,10 @@ index a49275f..1767823 100755
  {
  	return !(entry->ib1 & MTK_FOE_IB1_STATIC) &&
 diff --git a/drivers/net/ethernet/mediatek/mtk_ppe.h b/drivers/net/ethernet/mediatek/mtk_ppe.h
-index 8076e5d..c46c4d9 100644
+index 86288b0e6..e8cd0b1eb 100644
 --- a/drivers/net/ethernet/mediatek/mtk_ppe.h
 +++ b/drivers/net/ethernet/mediatek/mtk_ppe.h
-@@ -356,6 +356,7 @@ int mtk_foe_entry_set_vlan(struct mtk_foe_entry *entry, int vid);
+@@ -403,6 +403,7 @@ int mtk_foe_entry_set_vlan(struct mtk_foe_entry *entry, int vid);
  int mtk_foe_entry_set_pppoe(struct mtk_foe_entry *entry, int sid);
  int mtk_foe_entry_set_wdma(struct mtk_foe_entry *entry, int wdma_idx, int txq,
  			   int bss, int wcid);
@@ -211,7 +231,7 @@ index 8076e5d..c46c4d9 100644
  void mtk_foe_entry_clear(struct mtk_ppe *ppe, struct mtk_flow_entry *entry);
  int mtk_foe_entry_idle_time(struct mtk_ppe *ppe, struct mtk_flow_entry *entry);
 diff --git a/drivers/net/ethernet/mediatek/mtk_ppe_offload.c b/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
-index f258539..3b17819 100755
+index 05b5558e7..7bd825ba4 100755
 --- a/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
 +++ b/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
 @@ -9,6 +9,8 @@
@@ -232,9 +252,9 @@ index f258539..3b17819 100755
  			   int *wed_index)
  {
  	struct mtk_wdma_info info = {};
-@@ -211,6 +211,11 @@ mtk_flow_set_output_device(struct mtk_eth *eth, struct mtk_foe_entry *foe,
+@@ -209,6 +211,11 @@ mtk_flow_set_output_device(struct mtk_eth *eth, struct mtk_foe_entry *foe,
  	if (dsa_port >= 0)
- 	mtk_foe_entry_set_dsa(foe, dsa_port);
+ 		mtk_foe_entry_set_dsa(foe, dsa_port);
  
 +	if (eth->qos_toggle == 1 || ct->mark >= 6)
 +		mtk_foe_entry_set_qid(foe, ct->mark & MTK_QDMA_TX_MASK);
@@ -244,7 +264,7 @@ index f258539..3b17819 100755
  	if (dev == eth->netdev[0])
  		pse_port = PSE_GDM1_PORT;
  	else if (dev == eth->netdev[1])
-@@ -433,7 +443,7 @@ mtk_flow_offload_replace(struct mtk_eth *eth, struct flow_cls_offload *f)
+@@ -432,7 +439,7 @@ mtk_flow_offload_replace(struct mtk_eth *eth, struct flow_cls_offload *f)
  	if (data.pppoe.num == 1)
  		mtk_foe_entry_set_pppoe(&foe, data.pppoe.sid);
  
@@ -253,51 +273,12 @@ index f258539..3b17819 100755
  					 &wed_index);
  	if (err)
  		return err;
-diff --git a/include/net/flow_offload.h b/include/net/flow_offload.h
-index 59b8736..7261b6d 100644
---- a/include/net/flow_offload.h
-+++ b/include/net/flow_offload.h
-@@ -365,6 +378,7 @@ struct flow_cls_offload {
- 	struct flow_cls_common_offload common;
- 	enum flow_cls_command command;
- 	unsigned long cookie;
-+	struct flow_offload *flow;
- 	struct flow_rule *rule;
- 	struct flow_stats stats;
- 	u32 classid;
-diff --git a/net/netfilter/nf_flow_table_offload.c b/net/netfilter/nf_flow_table_offload.c
-index d94c6fb..886ced5 100644
---- a/net/netfilter/nf_flow_table_offload.c
-+++ b/net/netfilter/nf_flow_table_offload.c
-@@ -810,11 +810,13 @@ static int nf_flow_offload_alloc(const struct flow_offload_work *offload,
- }
- 
- static void nf_flow_offload_init(struct flow_cls_offload *cls_flow,
-+				 struct flow_offload *flow,
- 				 __be16 proto, int priority,
- 				 enum flow_cls_command cmd,
- 				 const struct flow_offload_tuple *tuple,
- 				 struct netlink_ext_ack *extack)
- {
-+	cls_flow->flow = flow;
- 	cls_flow->common.protocol = proto;
- 	cls_flow->common.prio = priority;
- 	cls_flow->common.extack = extack;
-@@ -836,7 +838,7 @@ static int nf_flow_offload_tuple(struct nf_flowtable *flowtable,
- 	__be16 proto = ETH_P_ALL;
- 	int err, i = 0;
- 
--	nf_flow_offload_init(&cls_flow, proto, priority, cmd,
-+	nf_flow_offload_init(&cls_flow, flow, proto, priority, cmd,
- 			     &flow->tuplehash[dir].tuple, &extack);
- 	if (cmd == FLOW_CLS_REPLACE)
- 		cls_flow.rule = flow_rule->rule;
 diff --git a/drivers/net/ethernet/mediatek/mtk_qdma_debugfs.c b/drivers/net/ethernet/mediatek/mtk_qdma_debugfs.c
 new file mode 100644
-index 0000000..198b924
+index 000000000..501cd2b12
 --- /dev/null
 +++ b/drivers/net/ethernet/mediatek/mtk_qdma_debugfs.c
-@@ -0,0 +1,433 @@
+@@ -0,0 +1,435 @@
 +/* SPDX-License-Identifier: GPL-2.0
 + *
 + * Copyright (c) 2022 MediaTek Inc.
@@ -424,7 +405,7 @@ index 0000000..198b924
 +	long id = (long)file->private_data;
 +	char *buf;
 +	unsigned int len = 0, buf_len = 1500;
-+	int enable, scheduling, max_rate, scheduler, i;
++	int enable, scheduling, max_rate, exp, scheduler, i;
 +	ssize_t ret_cnt;
 +	u32 val;
 +
@@ -440,10 +421,12 @@ index 0000000..198b924
 +	if (id & 0x1)
 +		val >>= 16;
 +
++	val &= MTK_QDMA_TX_SCH_MASK;
 +	enable     = FIELD_GET(MTK_QDMA_TX_SCH_RATE_EN, val);
 +	scheduling = FIELD_GET(MTK_QDMA_TX_SCH_MAX_WFQ, val);
 +	max_rate   = FIELD_GET(MTK_QDMA_TX_SCH_RATE_MAN, val);
-+	while (val--)
++	exp        = FIELD_GET(MTK_QDMA_TX_SCH_RATE_EXP, val);
++	while (exp--)
 +		max_rate *= 10;
 +
 +	len += scnprintf(buf + len, buf_len - len,
@@ -482,7 +465,7 @@ index 0000000..198b924
 +	char line[64] = {0}, scheduling[32];
 +	int enable, rate, exp = 0, shift = 0;
 +	size_t size;
-+	u32 val = 0;
++	u32 sch, val = 0;
 +
 +	if (length >= sizeof(line))
 +		return -EINVAL;
@@ -511,16 +494,16 @@ index 0000000..198b924
 +		shift = 16;
 +
 +	if (eth->soc->txrx.qdma_tx_sch == 4)
-+		val = readl(eth->base+ MTK_QDMA_TX_4SCH_BASE(id));
++		sch = readl(eth->base + MTK_QDMA_TX_4SCH_BASE(id));
 +	else
-+		val = readl(eth->base + MTK_QDMA_TX_2SCH_BASE);
++		sch = readl(eth->base + MTK_QDMA_TX_2SCH_BASE);
 +
-+	val &= ~(MTK_QDMA_TX_SCH_MASK << shift);
-+	val |= val << shift;
++	sch &= ~(MTK_QDMA_TX_SCH_MASK << shift);
++	sch |= val << shift;
 +	if (eth->soc->txrx.qdma_tx_sch == 4)
-+		writel(val, eth->base + MTK_QDMA_TX_4SCH_BASE(id));
++		writel(sch, eth->base + MTK_QDMA_TX_4SCH_BASE(id));
 +	else
-+		writel(val, eth->base + MTK_QDMA_TX_2SCH_BASE);
++		writel(sch, eth->base + MTK_QDMA_TX_2SCH_BASE);
 +
 +	size = strlen(line);
 +	*offset += size;
@@ -731,3 +714,45 @@ index 0000000..198b924
 +
 +	return 0;
 +}
+diff --git a/include/net/flow_offload.h b/include/net/flow_offload.h
+index 59b873653..c4eb45cb8 100644
+--- a/include/net/flow_offload.h
++++ b/include/net/flow_offload.h
+@@ -365,6 +365,7 @@ struct flow_cls_offload {
+ 	struct flow_cls_common_offload common;
+ 	enum flow_cls_command command;
+ 	unsigned long cookie;
++	struct flow_offload *flow;
+ 	struct flow_rule *rule;
+ 	struct flow_stats stats;
+ 	u32 classid;
+diff --git a/net/netfilter/nf_flow_table_offload.c b/net/netfilter/nf_flow_table_offload.c
+index b2c53c378..61cc51882 100644
+--- a/net/netfilter/nf_flow_table_offload.c
++++ b/net/netfilter/nf_flow_table_offload.c
+@@ -810,11 +810,13 @@ static int nf_flow_offload_alloc(const struct flow_offload_work *offload,
+ }
+ 
+ static void nf_flow_offload_init(struct flow_cls_offload *cls_flow,
++				 struct flow_offload *flow,
+ 				 __be16 proto, int priority,
+ 				 enum flow_cls_command cmd,
+ 				 const struct flow_offload_tuple *tuple,
+ 				 struct netlink_ext_ack *extack)
+ {
++	cls_flow->flow = flow;
+ 	cls_flow->common.protocol = proto;
+ 	cls_flow->common.prio = priority;
+ 	cls_flow->common.extack = extack;
+@@ -836,7 +838,7 @@ static int nf_flow_offload_tuple(struct nf_flowtable *flowtable,
+ 	__be16 proto = ETH_P_ALL;
+ 	int err, i = 0;
+ 
+-	nf_flow_offload_init(&cls_flow, proto, priority, cmd,
++	nf_flow_offload_init(&cls_flow, flow, proto, priority, cmd,
+ 			     &flow->tuplehash[dir].tuple, &extack);
+ 	if (cmd == FLOW_CLS_REPLACE)
+ 		cls_flow.rule = flow_rule->rule;
+-- 
+2.18.0
+
-- 
2.7.4

