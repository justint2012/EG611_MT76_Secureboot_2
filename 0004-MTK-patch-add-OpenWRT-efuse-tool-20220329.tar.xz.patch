From 0976fe1220adc44d9ff9bda11b3a0cdd23570e26 Mon Sep 17 00:00:00 2001
From: Justin Tsai <justin@gmail.com>
Date: Wed, 10 May 2023 10:46:12 +0800
Subject: [PATCH 04/12] [MTK patch] add OpenWRT-efuse-tool-20220329.tar.xz add
 tools to source code. if you want to build efuse package please enable two
 flags in .config CONFIG_PACKAGE_mtk-efuse-nl-tool=y
 CONFIG_PACKAGE_kmod-mtk-efuse-nl-drv=y

---
 .../applications/mtk-efuse-nl-tool/Makefile        |  49 ++
 .../applications/mtk-efuse-nl-tool/src/Makefile    |  10 +
 .../applications/mtk-efuse-nl-tool/src/mtk_efuse.c | 739 +++++++++++++++++++++
 .../applications/mtk-efuse-nl-tool/src/mtk_efuse.h |  98 +++
 .../mtk_soc/drivers/mtk-efuse-nl-drv/Makefile      |  41 ++
 .../mtk_soc/drivers/mtk-efuse-nl-drv/src/Makefile  |   1 +
 .../drivers/mtk-efuse-nl-drv/src/mtk_efuse.c       | 582 ++++++++++++++++
 .../drivers/mtk-efuse-nl-drv/src/mtk_efuse.h       | 199 ++++++
 8 files changed, 1719 insertions(+)
 create mode 100755 openwrt/package/mtk_soc/applications/mtk-efuse-nl-tool/Makefile
 create mode 100755 openwrt/package/mtk_soc/applications/mtk-efuse-nl-tool/src/Makefile
 create mode 100755 openwrt/package/mtk_soc/applications/mtk-efuse-nl-tool/src/mtk_efuse.c
 create mode 100755 openwrt/package/mtk_soc/applications/mtk-efuse-nl-tool/src/mtk_efuse.h
 create mode 100755 openwrt/package/mtk_soc/drivers/mtk-efuse-nl-drv/Makefile
 create mode 100755 openwrt/package/mtk_soc/drivers/mtk-efuse-nl-drv/src/Makefile
 create mode 100755 openwrt/package/mtk_soc/drivers/mtk-efuse-nl-drv/src/mtk_efuse.c
 create mode 100755 openwrt/package/mtk_soc/drivers/mtk-efuse-nl-drv/src/mtk_efuse.h

diff --git a/openwrt/package/mtk_soc/applications/mtk-efuse-nl-tool/Makefile b/openwrt/package/mtk_soc/applications/mtk-efuse-nl-tool/Makefile
new file mode 100755
index 0000000..7548112
--- /dev/null
+++ b/openwrt/package/mtk_soc/applications/mtk-efuse-nl-tool/Makefile
@@ -0,0 +1,49 @@
+#
+# Copyright (C) 2021 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=mtk-efuse-nl-tool
+PKG_RELEASE:=1
+
+PKG_BUILD_DIR:=$(BUILD_DIR)/$(PKG_NAME)
+include $(INCLUDE_DIR)/package.mk
+include $(INCLUDE_DIR)/kernel.mk
+
+define Package/mtk-efuse-nl-tool
+  SECTION:=MTK Properties
+  CATEGORY:=MTK Properties
+  TITLE:=MTK eFuse tool
+  SUBMENU:=Applications
+  DEPENDS:=+libnl-tiny +kmod-mtk-efuse-nl-drv
+endef
+
+define Package/mtk-efuse-nl-tool/description
+  MTK eFuse tool
+endef
+
+define Build/Configure
+endef
+
+TARGET_CFLAGS += \
+	-D_GNU_SOURCE \
+	-I$(STAGING_DIR)/usr/include/libnl-tiny \
+	-I$(PKG_BUILD_DIR)
+
+define Build/Compile
+	$(MAKE) -C $(PKG_BUILD_DIR) \
+		CC="$(TARGET_CC)" \
+		CFLAGS="$(TARGET_CFLAGS) -Wall" \
+		LDFLAGS="$(TARGET_LDFLAGS) -lnl-tiny -lm"
+endef
+
+define Package/mtk-efuse-nl-tool/install
+	$(INSTALL_DIR) $(1)/usr/sbin
+	$(INSTALL_BIN) $(PKG_BUILD_DIR)/mtk-efuse-tool $(1)/usr/sbin/
+endef
+
+$(eval $(call BuildPackage,mtk-efuse-nl-tool))
diff --git a/openwrt/package/mtk_soc/applications/mtk-efuse-nl-tool/src/Makefile b/openwrt/package/mtk_soc/applications/mtk-efuse-nl-tool/src/Makefile
new file mode 100755
index 0000000..7d1aafc
--- /dev/null
+++ b/openwrt/package/mtk_soc/applications/mtk-efuse-nl-tool/src/Makefile
@@ -0,0 +1,10 @@
+EXEC = mtk-efuse-tool
+SRC = mtk_efuse.c
+
+$(EXEC): $(SRC)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(SRC)
+
+all: $(EXEC)
+
+clean:
+	rm -f $(EXEC) *.o
diff --git a/openwrt/package/mtk_soc/applications/mtk-efuse-nl-tool/src/mtk_efuse.c b/openwrt/package/mtk_soc/applications/mtk-efuse-nl-tool/src/mtk_efuse.c
new file mode 100755
index 0000000..67ea6aa
--- /dev/null
+++ b/openwrt/package/mtk_soc/applications/mtk-efuse-nl-tool/src/mtk_efuse.c
@@ -0,0 +1,739 @@
+/* SPDX-License-Identifier:	GPL-2.0+ */
+/*
+ * Copyright (C) 2021 MediaTek Incorporation. All Rights Reserved.
+ *
+ * Author: Alvin Kuo <Alvin.Kuo@mediatek.com>
+ */
+
+#include <stdio.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <string.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netlink/netlink.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/ctrl.h>
+#include <netlink/genl/family.h>
+
+#include "mtk_efuse.h"
+
+static struct nl_sock *sock;
+static struct nl_cache *cache;
+static struct genl_family *family;
+
+static void print_usage(void)
+{
+	printf("Usage:\n");
+	printf(" mtk-efuse-tool [CMD] [HASH_NUMBER] [PKEY_HASH_FILE]\n");
+	printf(" [CMD] are:\n");
+	printf("    wh       write hash [PKEY_HASH_FILE] into the one\n");
+	printf("             [HASH_NUMBER] of four efuse hash fields\n");
+	printf("    rh       read hash from one [HASH_NUMBER] of four\n");
+	printf("             efuse hash fields\n");
+	printf("    lh       lock one [HASH_NUMBER] of four efuse hash\n");
+	printf("             fields\n");
+	printf("    cl       check if lock one [HASH_NUMBER] of four efuse\n");
+	printf("             hash fields\n");
+	printf("    dh       disable one [HASH_NUMBER] of four efuse hash\n");
+	printf("             fields\n");
+	printf("    cd       check if disable one [HASH_NUMBER] of four\n");
+	printf("             efuse hash fields\n");
+	printf("    es       enable secure boot of BROM\n");
+	printf("    cs       check if enable secure boot of BROM\n");
+	printf("    dj       disable JTAG\n");
+	printf("    cj       check if disable JTAG\n");
+	printf("    db       disable BROM CMD\n");
+	printf("    cb       check if disable BROM CMD\n");
+	printf("    ea       enable anti-rollback of BROM\n");
+	printf("    ca       check if enable anti-rollback of BROM\n");
+	printf("    ua       update eFuse anti-rollback version\n");
+	printf(" [HASH_NUMBER] are:\n");
+	printf("    0        PUBK0_HASH\n");
+	printf("    1        PUBK1_HASH\n");
+	printf("    2        PUBK2_HASH\n");
+	printf("    3        PUBK3_HASH\n");
+	printf(" Example:\n");
+	printf("  @For secure boot:\n");
+	printf("    mtk-efuse-tool wh 0 bl2.img.signkeyhash\n");
+	printf("    mtk-efuse-tool rh 0\n");
+	printf("    mtk-efuse-tool lh 0\n");
+	printf("    mtk-efuse-tool es\n");
+	printf("    mtk-efuse-tool dj\n");
+	printf("    mtk-efuse-tool db\n");
+	printf("  @For anti-rollback:\n");
+	printf("    mtk-efuse-tool ea\n");
+	printf("    mtk-efuse-tool ua\n");
+}
+
+static int verify_parameters(int argc,
+			     char *argv[])
+{
+	char *cmd;
+	uint32_t pubk_hash_num;
+
+	if (argc < 2) {
+		fprintf(stderr, "missing cmd\n");
+		return -EINVAL;
+	}
+
+	cmd = argv[1];
+	if (!strncmp(cmd, "wh", 2)) {
+		if (argc < 4) {
+			fprintf(stderr, "too few parameters\n");
+			return -EINVAL;
+		}
+
+		if (!isdigit(*argv[2])) {
+			fprintf(stderr, "hash number must be a numeric\n");
+			return -EINVAL;
+		}
+
+		pubk_hash_num = strtoul(argv[2], NULL, 10);
+		if (pubk_hash_num > 3) {
+			fprintf(stderr, "hash number out of range\n");
+			return -EINVAL;
+		}
+	} else if (!strncmp(cmd, "rh", 2) ||
+		   !strncmp(cmd, "lh", 2) ||
+		   !strncmp(cmd, "cl", 2) ||
+		   !strncmp(cmd, "dh", 2) ||
+		   !strncmp(cmd, "cd", 2) ) {
+		if (argc < 3) {
+			fprintf(stderr, "too few parameters\n");
+			return -EINVAL;
+		}
+
+		if (!isdigit(*argv[2])) {
+			fprintf(stderr, "hash number must be a numeric\n");
+			return -EINVAL;
+		}
+
+		pubk_hash_num = strtoul(argv[2], NULL, 10);
+		if (pubk_hash_num > 3) {
+			fprintf(stderr, "hash number out of range\n");
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static int mtk_efuse_read_pubk(char *file,
+			       uint8_t *buffer,
+			       uint32_t buffer_size)
+{
+	FILE *fp;
+	long len;
+
+	/* verify parameters */
+	if (!file || !buffer || buffer_size < MTK_EFUSE_PUBK_HASH_LEN)
+		return -EINVAL;
+
+	/* open file */ 
+	fp = fopen(file, "rb");
+	if (!fp) {
+		fprintf(stderr, "unable to open file\n");
+		return -1;
+	}
+
+	/* get file length */
+	if (fseek(fp, 0, SEEK_END)) {
+		fprintf(stderr, "unable to seek to end of file\n");
+		return -ferror(fp);
+	}
+	len = ftell(fp);
+	if (len < 0) {
+		fprintf(stderr, "unable to get the size of file\n");
+		return -ferror(fp);
+	}
+	rewind(fp);
+
+	/* check file length */
+	if (len < MTK_EFUSE_PUBK_HASH_LEN) {
+		fprintf(stderr, "file size less than public key hash length\n");
+		return -1;
+	}
+
+	/* read public key hash */
+	memset(buffer, 0x0, buffer_size);
+	len = fread(buffer, 1, MTK_EFUSE_PUBK_HASH_LEN, fp);
+	if (len != MTK_EFUSE_PUBK_HASH_LEN)
+		return -ferror(fp);
+
+	return 0;
+}
+
+static void mtk_efuse_nl_free(void)
+{
+	if (family)
+		nl_object_put((struct nl_object *)family);
+	if (cache)
+		nl_cache_free(cache);
+	if (sock)
+		nl_socket_free(sock);
+
+	sock = NULL;
+	cache = NULL;
+	family = NULL;
+}
+
+int mtk_efuse_nl_init(void)
+{
+	int ret;
+
+	sock = NULL;
+	cache = NULL;
+	family = NULL;
+
+	/* allocate a new netlink socket */
+	sock = nl_socket_alloc();
+	if (!sock) {
+		fprintf(stderr, "failed to create socket\n");
+		goto error;
+	}
+
+	/* connect a generic netlink socket*/
+	ret = genl_connect(sock);
+	if (ret <0) {
+		fprintf(stderr, "failed to connect a generic netlink socket\n");
+		goto error;
+	}
+
+	/* allocate a new controller cache */
+	ret = genl_ctrl_alloc_cache(sock, &cache);
+	if (ret < 0) {
+		fprintf(stderr, "failed to allocate a controller cache\n");
+		goto error;
+	}
+
+	/* search controller cache for a family name match */
+	family = genl_ctrl_search_by_name(cache, MTK_EFUSE_NL_GENL_NAME);
+	if (!family) {
+		fprintf(stderr,"netlink family (%s) not found\n",
+			MTK_EFUSE_NL_GENL_NAME);
+		goto error;
+	}
+
+	return 0;
+
+error:
+	mtk_efuse_nl_free();
+	return -EINVAL;
+}
+
+static int construct_attrs(struct nl_msg *msg,
+			   void *arg)
+{
+	uint32_t idx;
+        struct mtk_efuse_data_t *data = arg;
+	struct genlmsghdr *genlh = nlmsg_data(nlmsg_hdr(msg));
+
+	/* put efuse field into netlink msg */
+	nla_put_u32(msg,
+		    MTK_EFUSE_NL_ATTR_TYPE_EFUSE_FIELD,
+		    data->efuse_field);
+
+	if (genlh->cmd == MTK_EFUSE_NL_CMD_WRITE) {
+		/* put value into netlink msg */
+		nla_put_u32(msg,
+			    MTK_EFUSE_NL_ATTR_TYPE_EFUSE_VALUE,
+			    data->efuse_value);
+	}
+
+	if (genlh->cmd == MTK_EFUSE_NL_CMD_WRITE_PUBK_HASH) {
+		/* put public key hash into netlink msg */
+		for (idx = 0; idx < MTK_EFUSE_PUBK_HASH_INDEX_MAX; idx++) {
+			nla_put_u32(msg,
+				    MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH0 + idx,
+				    data->pubk_hash[idx]);
+		}
+	}
+
+        return 0;
+}
+
+static int spilt_attrs(struct nl_msg *msg,
+		       void *arg)
+{
+	int ret;
+	uint32_t idx;
+        struct mtk_efuse_data_t *data = arg;
+	struct genlmsghdr *genlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *nl_attrs[MTK_EFUSE_NL_ATTR_TYPE_MAX + 1];
+
+	/* parse netlink msg */
+	ret = nla_parse(nl_attrs, MTK_EFUSE_NL_ATTR_TYPE_MAX, 
+			genlmsg_attrdata(genlh, 0), genlmsg_attrlen(genlh, 0),
+			NULL);
+	if (ret < 0) {
+		fprintf(stderr,"netlink msg parse fail (%d)\n", ret);
+		goto done;
+	}
+
+	if (genlh->cmd == MTK_EFUSE_NL_CMD_READ) {
+		/* get value */
+		data->efuse_value =
+			nla_get_u32(nl_attrs[MTK_EFUSE_NL_ATTR_TYPE_EFUSE_VALUE]);
+	}
+
+	if (genlh->cmd == MTK_EFUSE_NL_CMD_READ_PUBK_HASH) {
+		/* get public key hash */
+		for (idx =0; idx < MTK_EFUSE_PUBK_HASH_INDEX_MAX; idx++) {
+			data->pubk_hash[idx] =
+				nla_get_u32(nl_attrs[MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH0 + idx]);
+		}
+	}
+
+	return 0;
+
+done:
+	return NL_SKIP;
+}
+
+static int wait_handler(struct nl_msg *msg,
+			void *arg)
+{
+        int *finished = arg;
+
+        *finished = 1;
+        return NL_STOP;
+}
+
+static int mtk_efuse_nl_request(int cmd,
+				int (*spilt)(struct nl_msg *, void *),
+				int (*construct)(struct nl_msg *, void *),
+				void *arg)
+{
+        int ret = -1;
+        int finished;
+        int flags = 0;
+        struct nl_msg *msg;
+        struct nl_cb *callback = NULL;
+
+        /* allocate an netllink message buffer */
+	msg = nlmsg_alloc();
+	if (!msg) {
+		fprintf(stderr, "failed to allocate netlink message\n");
+		return -ENOMEM;
+	}
+
+	/* add generic netlink headers to netlink message */
+	genlmsg_put(msg, NL_AUTO_PID, NL_AUTO_SEQ,
+		    genl_family_get_id(family), 0, flags, cmd, 0);
+
+	/* fill attaribute of netlink message via construct function */
+	if (construct) {
+		ret = construct(msg, arg);
+		if (ret < 0) {
+			fprintf(stderr, "construct attribute fail\n");
+			goto error;
+		}
+	}
+
+	/* allocate a new callback handler */
+	callback = nl_cb_alloc(NL_CB_CUSTOM);
+	if (!callback) {
+		fprintf(stderr, "failed to allocate callback handler\n");
+		goto error;
+	}
+
+	/* send netlink message */
+	ret = nl_send_auto_complete(sock, msg);
+	if (ret < 0) {
+		fprintf(stderr, "send netlink msg fail (%d)\n", ret);
+		goto error;
+	}
+
+	finished = 0;
+	if (spilt) {
+		nl_cb_set(callback, NL_CB_VALID, NL_CB_CUSTOM,
+			  spilt, arg);
+		nl_cb_set(callback, NL_CB_FINISH, NL_CB_CUSTOM,
+			  wait_handler, &finished);
+	} else {
+		nl_cb_set(callback, NL_CB_ACK, NL_CB_CUSTOM,
+			  wait_handler, &finished);
+	}
+
+	/* receive message from kernel request */
+	ret = nl_recvmsgs(sock, callback);
+	if (ret < 0) {
+		fprintf(stderr, "receive msg fail (%d)\n", ret);
+		goto error;
+	}
+
+	/* wait until an ACK is received for the latest not yet acknowledge*/
+	if (!finished) {
+		ret = nl_wait_for_ack(sock);
+		if (ret < 0) {
+			fprintf(stderr, "wait ack fail (%d)\n", ret);
+			goto error;
+		}
+	}
+
+error:
+	if (callback)
+		nl_cb_put(callback);
+
+	if (msg)
+		nlmsg_free(msg);
+
+        return ret;
+}
+
+int main(int argc, char *argv[])
+{
+	char *cmd;
+	int ret = 0;
+	uint32_t idx;
+	char *pubk_hash_file;
+	uint32_t pubk_hash_num;
+	struct mtk_efuse_data_t data = { 0 };
+
+	ret = verify_parameters(argc, argv);
+	if (ret) {
+		print_usage();
+		goto error;
+	}
+
+	ret = mtk_efuse_nl_init();
+	if (ret) {
+		fprintf(stderr,
+			"netlink init fail(%d)\n", ret);
+		goto error;
+	}
+
+	cmd = argv[1];
+	if (!strncmp(cmd, "wh", 2)) {
+		/* get efuse field of public key hash */
+		pubk_hash_num = strtoul(argv[2], NULL, 10);
+		data.efuse_field =
+			MTK_EFUSE_FIELD_SBC_PUBK0_HASH + pubk_hash_num;
+
+		/* get public key hash */
+		pubk_hash_file = argv[3];
+		ret = mtk_efuse_read_pubk(pubk_hash_file,
+					  (uint8_t *)data.pubk_hash,
+					  sizeof(data.pubk_hash));
+		if (ret) {
+			fprintf(stderr,
+				"read public key from \"%s\" fail (%d)\n",
+				pubk_hash_file, ret);
+			goto error;
+		}
+
+		/* send netlink request */
+		ret = mtk_efuse_nl_request(MTK_EFUSE_NL_CMD_WRITE_PUBK_HASH,
+					   NULL,
+					   construct_attrs,
+					   &data);
+		if (ret) {
+			fprintf(stderr,
+				"netlink request fail (%d) for '%s'\n",
+				ret, cmd);
+			goto error;
+		}
+	} else if (!strncmp(cmd, "rh", 2)) {
+		/* get efuse field of public key hash */
+		pubk_hash_num = strtoul(argv[2], NULL, 10);
+		data.efuse_field =
+			MTK_EFUSE_FIELD_SBC_PUBK0_HASH + pubk_hash_num;
+
+		/* send netlink request */
+		ret = mtk_efuse_nl_request(MTK_EFUSE_NL_CMD_READ_PUBK_HASH,
+					   spilt_attrs,
+					   construct_attrs,
+					   &data);
+		if (ret) {
+			fprintf(stderr,
+				"netlink request fail (%d) for '%s'\n",
+				ret, cmd);
+			goto error;
+		}
+
+		/* print public key hash */
+		printf("PUBK%d_HASH :", pubk_hash_num);
+		for (idx = 0; idx < MTK_EFUSE_PUBK_HASH_LEN; idx++) {
+			if (idx % 16 == 0)
+				printf("\n%08x ", idx);
+			if (idx % 8 == 0)
+				printf(" ");
+			printf("%02x ", ((uint8_t *)(data.pubk_hash))[idx]);
+		}
+		printf("\n");
+	} else if (!strncmp(cmd, "lh", 2)) {
+		/* get efuse field of public key lock */
+		pubk_hash_num = strtoul(argv[2], NULL, 10);
+		data.efuse_field =
+			MTK_EFUSE_FIELD_SBC_PUBK0_HASH_LOCK + pubk_hash_num;
+
+		/* fill in efuse value */
+		data.efuse_value = 0x00000001;
+
+		/* send netlink request */
+		ret = mtk_efuse_nl_request(MTK_EFUSE_NL_CMD_WRITE,
+					   NULL,
+					   construct_attrs,
+					   &data);
+		if (ret) {
+			fprintf(stderr,
+				"netlink request fail (%d) for '%s'\n",
+				ret, cmd);
+			goto error;
+		}
+	} else if (!strncmp(cmd, "cl", 2)) {
+		/* get efuse field of public key lock */
+		pubk_hash_num = strtoul(argv[2], NULL, 10);
+		data.efuse_field =
+			MTK_EFUSE_FIELD_SBC_PUBK0_HASH_LOCK + pubk_hash_num;
+
+		/* send netlink request */
+		ret = mtk_efuse_nl_request(MTK_EFUSE_NL_CMD_READ,
+					   spilt_attrs,
+					   construct_attrs,
+					   &data);
+		if (ret) {
+			fprintf(stderr,
+				"netlink request fail (%d) for '%s'\n",
+				ret, cmd);
+			goto error;
+		}
+
+		/* print result */
+		printf("PUBK%d_HASH : ", pubk_hash_num);
+		if (data.efuse_value == 0x00000001)
+			printf("lock\n");
+		else
+			printf("unlock\n");
+	} else if (!strncmp(cmd, "dh", 2)) {
+		/* get efuse field of public key disable */
+		pubk_hash_num = strtoul(argv[2], NULL, 10);
+		data.efuse_field =
+			MTK_EFUSE_FIELD_SBC_PUBK0_HASH_DIS + pubk_hash_num;
+
+		/* fill in efuse value */
+		data.efuse_value = 0x00000001;
+
+		/* send netlink request */
+		ret = mtk_efuse_nl_request(MTK_EFUSE_NL_CMD_WRITE,
+					   NULL,
+					   construct_attrs,
+					   &data);
+		if (ret) {
+			fprintf(stderr,
+				"netlink request fail (%d) for '%s'\n",
+				ret, cmd);
+			goto error;
+		}
+	} else if (!strncmp(cmd, "cd", 2)) {
+		/* get efuse field of public key disable */
+		pubk_hash_num = strtoul(argv[2], NULL, 10);
+		data.efuse_field =
+			MTK_EFUSE_FIELD_SBC_PUBK0_HASH_DIS + pubk_hash_num;
+
+		/* send netlink request */
+		ret = mtk_efuse_nl_request(MTK_EFUSE_NL_CMD_READ,
+					   spilt_attrs,
+					   construct_attrs,
+					   &data);
+		if (ret) {
+			fprintf(stderr,
+				"netlink request fail (%d) for '%s'\n",
+				ret, cmd);
+			goto error;
+		}
+
+		/* print result */
+		printf("PUBK%d_HASH : ", pubk_hash_num);
+		if (data.efuse_value == 0x00000001)
+			printf("disable\n");
+		else
+			printf("enable\n");
+	} else if (!strncmp(cmd, "es", 2)) {
+		/* fill in efuse field */
+		data.efuse_field = MTK_EFUSE_FIELD_SBC_EN;
+
+		/* fill in efuse value */
+		data.efuse_value = 0x00000001;
+
+		/* send netlink request */
+		ret = mtk_efuse_nl_request(MTK_EFUSE_NL_CMD_WRITE,
+					   NULL,
+					   construct_attrs,
+					   &data);
+		if (ret) {
+			fprintf(stderr,
+				"netlink request fail (%d) for '%s'\n",
+				ret, cmd);
+			goto error;
+		}
+	} else if (!strncmp(cmd, "cs", 2)) {
+		/* fill in efuse field */
+		data.efuse_field = MTK_EFUSE_FIELD_SBC_EN;
+
+		/* send netlink request */
+		ret = mtk_efuse_nl_request(MTK_EFUSE_NL_CMD_READ,
+					   spilt_attrs,
+					   construct_attrs,
+					   &data);
+		if (ret) {
+			fprintf(stderr,
+				"netlink request fail (%d) for '%s'\n",
+				ret, cmd);
+			goto error;
+		}
+
+		/* print result */
+		printf("Secure Boot : ");
+		if (data.efuse_value == 0x00000001)
+			printf("enable\n");
+		else
+			printf("disable\n");
+	} else if (!strncmp(cmd, "dj", 2)) {
+		/* fill in efuse field */
+		data.efuse_field = MTK_EFUSE_FIELD_JTAG_DIS;
+
+		/* fill in efuse value */
+		data.efuse_value = 0x00000001;
+
+		/* send netlink request */
+		ret = mtk_efuse_nl_request(MTK_EFUSE_NL_CMD_WRITE,
+					   NULL,
+					   construct_attrs,
+					   &data);
+		if (ret) {
+			fprintf(stderr,
+				"netlink request fail (%d) for '%s'\n",
+				ret, cmd);
+			goto error;
+		}
+	} else if (!strncmp(cmd, "cj", 2)) {
+		/* fill in efuse field */
+		data.efuse_field = MTK_EFUSE_FIELD_JTAG_DIS;
+
+		/* send netlink request */
+		ret = mtk_efuse_nl_request(MTK_EFUSE_NL_CMD_READ,
+					   spilt_attrs,
+					   construct_attrs,
+					   &data);
+		if (ret) {
+			fprintf(stderr,
+				"netlink request fail (%d) for '%s'\n",
+				ret, cmd);
+			goto error;
+		}
+
+		/* print result */
+		printf("JTAG : ");
+		if (data.efuse_value == 0x00000001)
+			printf("disable\n");
+		else
+			printf("enable\n");
+	} else if (!strncmp(cmd, "db", 2)) {
+		/* fill in efuse field */
+		data.efuse_field = MTK_EFUSE_FIELD_BROM_CMD_DIS;
+
+		/* fill in efuse value */
+		data.efuse_value = 0x00000001;
+
+		/* send netlink request */
+		ret = mtk_efuse_nl_request(MTK_EFUSE_NL_CMD_WRITE,
+					   NULL,
+					   construct_attrs,
+					   &data);
+		if (ret) {
+			fprintf(stderr,
+				"netlink request fail (%d) for '%s'\n",
+				ret, cmd);
+			goto error;
+		}
+	} else if (!strncmp(cmd, "cb", 2)) {
+		/* fill in efuse field */
+		data.efuse_field = MTK_EFUSE_FIELD_BROM_CMD_DIS;
+
+		/* send netlink request */
+		ret = mtk_efuse_nl_request(MTK_EFUSE_NL_CMD_READ,
+					   spilt_attrs,
+					   construct_attrs,
+					   &data);
+		if (ret) {
+			fprintf(stderr,
+				"netlink request fail (%d) for '%s'\n",
+				ret, cmd);
+			goto error;
+		}
+
+		/* print result */
+		printf("BROM CMD : ");
+		if (data.efuse_value == 0x00000001)
+			printf("disable\n");
+		else
+			printf("enable\n");
+	} else if (!strncmp(cmd, "ea", 2)) {
+		/* fill in efuse field */
+		data.efuse_field = MTK_EFUSE_FIELD_AR_EN;
+
+		/* fill in efuse value */
+		data.efuse_value = 0x00000001;
+
+		/* send netlink request */
+		ret = mtk_efuse_nl_request(MTK_EFUSE_NL_CMD_WRITE,
+					   NULL,
+					   construct_attrs,
+					   &data);
+		if (ret) {
+			fprintf(stderr,
+				"netlink request fail (%d) for '%s'\n",
+				ret, cmd);
+			goto error;
+		}
+	} else if (!strncmp(cmd, "ca", 2)) {
+		/* fill in efuse field */
+		data.efuse_field = MTK_EFUSE_FIELD_AR_EN;
+
+		/* send netlink request */
+		ret = mtk_efuse_nl_request(MTK_EFUSE_NL_CMD_READ,
+					   spilt_attrs,
+					   construct_attrs,
+					   &data);
+		if (ret) {
+			fprintf(stderr,
+				"netlink request fail (%d) for '%s'\n",
+				ret, cmd);
+			goto error;
+		}
+
+		/* print result */
+		printf("Anti-Rollback : ");
+		if (data.efuse_value == 0x00000001)
+			printf("enable\n");
+		else
+			printf("disable\n");
+	} else if (!strncmp(cmd, "ua", 2)) {
+		/* send netlink request */
+		ret = mtk_efuse_nl_request(MTK_EFUSE_NL_CMD_UPDATE_AR_VER,
+					   NULL,
+					   NULL,
+					   NULL);
+		if (ret) {
+			fprintf(stderr,
+				"netlink request fail (%d) for '%s'\n",
+				ret, cmd);
+			goto error;
+		}
+	} else {
+		fprintf(stderr, "unsupported cmd '%s'\n", cmd);
+		goto error;
+	}
+
+	printf("\nefuse operate (%s) success\n", cmd);
+error :
+	mtk_efuse_nl_free();
+	return ret;
+}
diff --git a/openwrt/package/mtk_soc/applications/mtk-efuse-nl-tool/src/mtk_efuse.h b/openwrt/package/mtk_soc/applications/mtk-efuse-nl-tool/src/mtk_efuse.h
new file mode 100755
index 0000000..500a4cc
--- /dev/null
+++ b/openwrt/package/mtk_soc/applications/mtk-efuse-nl-tool/src/mtk_efuse.h
@@ -0,0 +1,98 @@
+/* SPDX-License-Identifier:	GPL-2.0+ */
+/*
+ * Copyright (C) 2021 MediaTek Incorporation. All Rights Reserved.
+ *
+ * Author: Alvin Kuo <Alvin.Kuo@mediatek.com>
+ */
+#ifndef __MTK_EFUSE_H__
+#define __MTK_EFUSE_H__
+
+/*********************************************************************************
+ *
+ *  eFuse info (DO NOT EDIT, it copy from ATF)
+ *
+ ********************************************************************************/
+enum MTK_EFUSE_FIELD {
+	MTK_EFUSE_FIELD_SBC_PUBK0_HASH = 0,
+	MTK_EFUSE_FIELD_SBC_PUBK1_HASH,
+	MTK_EFUSE_FIELD_SBC_PUBK2_HASH,
+	MTK_EFUSE_FIELD_SBC_PUBK3_HASH,
+	MTK_EFUSE_FIELD_SBC_PUBK0_HASH_LOCK,
+	MTK_EFUSE_FIELD_SBC_PUBK1_HASH_LOCK,
+	MTK_EFUSE_FIELD_SBC_PUBK2_HASH_LOCK,
+	MTK_EFUSE_FIELD_SBC_PUBK3_HASH_LOCK,
+	MTK_EFUSE_FIELD_SBC_PUBK0_HASH_DIS,
+	MTK_EFUSE_FIELD_SBC_PUBK1_HASH_DIS,
+	MTK_EFUSE_FIELD_SBC_PUBK2_HASH_DIS,
+	MTK_EFUSE_FIELD_SBC_PUBK3_HASH_DIS,
+	MTK_EFUSE_FIELD_JTAG_DIS,
+	MTK_EFUSE_FIELD_SBC_EN,
+	MTK_EFUSE_FIELD_AR_EN,
+	MTK_EFUSE_FIELD_DAA_EN,
+	MTK_EFUSE_FIELD_BROM_CMD_DIS,
+	__MTK_EFUSE_FIELD_MAX,
+};
+#define MTK_EFUSE_FIELD_MAX (__MTK_EFUSE_FIELD_MAX)
+
+enum MTK_EFUSE_PUBK_HASH_INDEX {
+	MTK_EFUSE_PUBK_HASH_INDEX0 = 0,
+	MTK_EFUSE_PUBK_HASH_INDEX1,
+	MTK_EFUSE_PUBK_HASH_INDEX2,
+	MTK_EFUSE_PUBK_HASH_INDEX3,
+	MTK_EFUSE_PUBK_HASH_INDEX4,
+	MTK_EFUSE_PUBK_HASH_INDEX5,
+	MTK_EFUSE_PUBK_HASH_INDEX6,
+	MTK_EFUSE_PUBK_HASH_INDEX7,
+	__MTK_EFUSE_PUBK_HASH_INDEX_MAX,
+};
+#define MTK_EFUSE_PUBK_HASH_INDEX_MAX (__MTK_EFUSE_PUBK_HASH_INDEX_MAX)
+
+#define MTK_EFUSE_PUBK_HASH_LEN			32
+
+/*********************************************************************************
+ *
+ *  netlink info
+ *
+ ********************************************************************************/
+#define MTK_EFUSE_NL_GENL_NAME			"mtk-efuse"
+#define MTK_EFUSE_NL_GENL_VERSION		0x1
+
+enum MTK_EFUSE_NL_CMD {
+	MTK_EFUSE_NL_CMD_UNSPEC = 0,
+	MTK_EFUSE_NL_CMD_READ,
+	MTK_EFUSE_NL_CMD_READ_PUBK_HASH,
+	MTK_EFUSE_NL_CMD_WRITE,
+	MTK_EFUSE_NL_CMD_WRITE_PUBK_HASH,
+	MTK_EFUSE_NL_CMD_UPDATE_AR_VER,
+	__MTK_EFUSE_NL_CMD_MAX
+};
+#define MTK_EFUSE_NL_CMD_MAX (__MTK_EFUSE_NL_CMD_MAX - 1)
+
+enum MTK_EFUSE_NL_ATTR_TYPE {
+	MTK_EFUSE_NL_ATTR_TYPE_UNSPEC = 0,
+	MTK_EFUSE_NL_ATTR_TYPE_EFUSE_FIELD,
+	MTK_EFUSE_NL_ATTR_TYPE_EFUSE_VALUE,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH0,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH1,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH2,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH3,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH4,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH5,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH6,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH7,
+	__MTK_EFUSE_NL_ATTR_TYPE_MAX,
+};
+#define MTK_EFUSE_NL_ATTR_TYPE_MAX (__MTK_EFUSE_NL_ATTR_TYPE_MAX - 1)
+
+/*********************************************************************************
+ *
+ *  efuse data in user space
+ *
+ ********************************************************************************/
+struct mtk_efuse_data_t {
+	uint32_t efuse_field;
+	uint32_t efuse_value;
+	uint32_t pubk_hash[MTK_EFUSE_PUBK_HASH_INDEX_MAX];
+};
+
+#endif /* __MTK_EFUSE_H__ */
diff --git a/openwrt/package/mtk_soc/drivers/mtk-efuse-nl-drv/Makefile b/openwrt/package/mtk_soc/drivers/mtk-efuse-nl-drv/Makefile
new file mode 100755
index 0000000..9d842b5
--- /dev/null
+++ b/openwrt/package/mtk_soc/drivers/mtk-efuse-nl-drv/Makefile
@@ -0,0 +1,41 @@
+#
+# Copyright (C) 2008-2012 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+include $(TOPDIR)/rules.mk
+include $(INCLUDE_DIR)/kernel.mk
+
+PKG_NAME:=mtk-efuse-nl-drv
+PKG_RELEASE:=1
+
+include $(INCLUDE_DIR)/package.mk
+
+define KernelPackage/mtk-efuse-nl-drv
+  SECTION:=MTK Properties
+  CATEGORY:=MTK Properties
+  TITLE:=MTK eFuse driver
+  SUBMENU:=Drivers
+  FILES:=$(PKG_BUILD_DIR)/mtk_efuse.ko
+  AUTOLOAD:=$(call AutoLoad,81,mtk_efuse)
+endef
+
+define KernelPackage/mtk-efuse-nl-drv/description
+  MTK eFuse driver
+endef
+
+MAKE_OPTS:= \
+	$(KERNEL_MAKE_FLAGS) \
+	M="$(PKG_BUILD_DIR)" \
+	EXTRA_CFLAGS="$(EXTRA_CFLAGS)" \
+	$(EXTRA_KCONFIG)
+
+define Build/Compile
+	$(MAKE) -C "$(LINUX_DIR)" \
+		$(MAKE_OPTS) \
+		modules
+endef
+
+$(eval $(call KernelPackage,mtk-efuse-nl-drv))
diff --git a/openwrt/package/mtk_soc/drivers/mtk-efuse-nl-drv/src/Makefile b/openwrt/package/mtk_soc/drivers/mtk-efuse-nl-drv/src/Makefile
new file mode 100755
index 0000000..6fb5b77
--- /dev/null
+++ b/openwrt/package/mtk_soc/drivers/mtk-efuse-nl-drv/src/Makefile
@@ -0,0 +1 @@
+obj-m += mtk_efuse.o
diff --git a/openwrt/package/mtk_soc/drivers/mtk-efuse-nl-drv/src/mtk_efuse.c b/openwrt/package/mtk_soc/drivers/mtk-efuse-nl-drv/src/mtk_efuse.c
new file mode 100755
index 0000000..a91b0bb
--- /dev/null
+++ b/openwrt/package/mtk_soc/drivers/mtk-efuse-nl-drv/src/mtk_efuse.c
@@ -0,0 +1,582 @@
+/* SPDX-License-Identifier:	GPL-2.0+ */
+/*
+ * Copyright (C) 2021 MediaTek Incorporation. All Rights Reserved.
+ *
+ * Author: Alvin Kuo <Alvin.Kuo@mediatek.com>
+ */
+
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/arm-smccc.h>
+#include <net/genetlink.h>
+
+#include "mtk_efuse.h"
+
+/*
+ *  define private netlink command type
+ */
+struct mtk_efuse_nl_cmd_t {
+	enum MTK_EFUSE_NL_CMD cmd;
+	int (*process)(struct genl_info *info);
+	const enum MTK_EFUSE_NL_ATTR_TYPE *req_attrs;
+	u32 req_attrs_num;
+};
+
+#define MTK_EFUSE_NL_CMD_REQ_ATTRS(attr) \
+	.req_attrs = attr, \
+	.req_attrs_num = ARRAY_SIZE(attr),
+
+static const enum MTK_EFUSE_NL_ATTR_TYPE
+mtk_efuse_nl_cmd_read_attrs[] = {
+	MTK_EFUSE_NL_ATTR_TYPE_EFUSE_FIELD,
+};
+
+static const enum MTK_EFUSE_NL_ATTR_TYPE
+mtk_efuse_nl_cmd_read_pubk_hash_attrs[] = {
+	MTK_EFUSE_NL_ATTR_TYPE_EFUSE_FIELD,
+};
+
+static const enum MTK_EFUSE_NL_ATTR_TYPE
+mtk_efuse_nl_cmd_write_attrs[] = {
+	MTK_EFUSE_NL_ATTR_TYPE_EFUSE_FIELD,
+	MTK_EFUSE_NL_ATTR_TYPE_EFUSE_VALUE,
+};
+
+static const enum MTK_EFUSE_NL_ATTR_TYPE
+mtk_efuse_nl_cmd_write_pubk_hash_attrs[] = {
+	MTK_EFUSE_NL_ATTR_TYPE_EFUSE_FIELD,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH0,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH1,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH2,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH3,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH4,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH5,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH6,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH7,
+};
+
+/* 
+ *  define process function and required attributes
+ *  for each supported netlink command
+ */
+static const struct mtk_efuse_nl_cmd_t
+mtk_efuse_nl_cmds[] = {
+	{
+		.cmd = MTK_EFUSE_NL_CMD_READ,
+		.process = mtk_efuse_nl_reply_read,
+		MTK_EFUSE_NL_CMD_REQ_ATTRS(mtk_efuse_nl_cmd_read_attrs)
+	}, {
+		.cmd = MTK_EFUSE_NL_CMD_READ_PUBK_HASH,
+		.process = mtk_efuse_nl_reply_read_pubk_hash,
+		MTK_EFUSE_NL_CMD_REQ_ATTRS(mtk_efuse_nl_cmd_read_pubk_hash_attrs)
+	}, {
+		.cmd = MTK_EFUSE_NL_CMD_WRITE,
+		.process = mtk_efuse_nl_reply_write,
+		MTK_EFUSE_NL_CMD_REQ_ATTRS(mtk_efuse_nl_cmd_write_attrs)
+	}, {
+		.cmd = MTK_EFUSE_NL_CMD_WRITE_PUBK_HASH,
+		.process = mtk_efuse_nl_reply_write_pubk_hash,
+		MTK_EFUSE_NL_CMD_REQ_ATTRS(mtk_efuse_nl_cmd_write_pubk_hash_attrs)
+	}, {
+		.cmd = MTK_EFUSE_NL_CMD_UPDATE_AR_VER,
+		.process = mtk_efuse_nl_reply_update_ar_ver,
+		.req_attrs = NULL,
+		.req_attrs_num = 0,
+	},
+};
+
+/*  
+ *  define netlink attribute type
+ */
+static const struct nla_policy
+mtk_efuse_nl_cmd_policy[] = {
+	[MTK_EFUSE_NL_ATTR_TYPE_EFUSE_FIELD] = { .type = NLA_U32 },
+	[MTK_EFUSE_NL_ATTR_TYPE_EFUSE_VALUE] = { .type = NLA_U32 },
+	[MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH0] = { .type = NLA_U32 },
+	[MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH1] = { .type = NLA_U32 },
+	[MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH2] = { .type = NLA_U32 },
+	[MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH3] = { .type = NLA_U32 },
+	[MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH4] = { .type = NLA_U32 },
+	[MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH5] = { .type = NLA_U32 },
+	[MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH6] = { .type = NLA_U32 },
+	[MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH7] = { .type = NLA_U32 },
+};
+
+/*  
+ *  define supported netlink command
+ */
+static const struct genl_ops
+mtk_efuse_nl_ops[] = {
+	{
+		.cmd = MTK_EFUSE_NL_CMD_READ,
+		.doit = mtk_efuse_nl_response,
+		.flags = GENL_ADMIN_PERM,
+	}, {
+		.cmd = MTK_EFUSE_NL_CMD_READ_PUBK_HASH,
+		.doit = mtk_efuse_nl_response,
+		.flags = GENL_ADMIN_PERM,
+	}, {
+		.cmd = MTK_EFUSE_NL_CMD_WRITE,
+		.doit = mtk_efuse_nl_response,
+		.flags = GENL_ADMIN_PERM,
+	}, {
+		.cmd = MTK_EFUSE_NL_CMD_WRITE_PUBK_HASH,
+		.doit = mtk_efuse_nl_response,
+		.flags = GENL_ADMIN_PERM,
+	}, {
+		.cmd = MTK_EFUSE_NL_CMD_UPDATE_AR_VER,
+		.doit = mtk_efuse_nl_response,
+		.flags = GENL_ADMIN_PERM,
+	},
+};
+
+static struct genl_family
+mtk_efuse_nl_family = {
+	.name = MTK_EFUSE_NL_GENL_NAME,
+	.version = MTK_EFUSE_NL_GENL_VERSION,
+	.maxattr = MTK_EFUSE_NL_ATTR_TYPE_MAX,
+	.ops = mtk_efuse_nl_ops,
+	.n_ops = ARRAY_SIZE(mtk_efuse_nl_ops),
+	.policy = mtk_efuse_nl_cmd_policy,
+};
+
+static int mtk_efuse_smc(u32 smc_fid,
+			 u32 x1,
+			 u32 x2,
+			 u32 x3,
+			 u32 x4,
+			 struct arm_smccc_res *res)
+{
+	/* SMC64 calling convention is used if in 64bits Linux */
+	if (sizeof(void *) == 8)
+		smc_fid |= (0x1 << 30);
+
+	arm_smccc_smc(smc_fid, x1, x2, x3, x4, 0x0, 0x0, 0x0, res);
+
+	return 0;
+}
+
+static int mtk_efuse_read(u32 efuse_field,
+			  u8 *read_buffer,
+			  u32 read_buffer_len)
+{
+	int ret;
+	u32 idx;
+	u32 offset;
+	u32 efuse_len;
+	u32 efuse_data[2] = { 0 };
+	static struct arm_smccc_res res;
+
+	/* get efuse length */
+	ret = mtk_efuse_smc(MTK_SIP_EFUSE_GET_LEN,
+			    efuse_field, 0x0, 0x0, 0x0,
+			    &res);
+	if (ret < 0)
+		return ret;
+	else if (res.a0 != MTK_EFUSE_SUCCESS) {
+		pr_err("%s : get efuse length fail (%lu)\n",
+		       __func__, res.a0);
+		return -1;
+	}
+	efuse_len = res.a1;
+
+	/* verify efuse_buffer */
+	if (!read_buffer)
+		return -EINVAL;
+	if (read_buffer_len < efuse_len)
+		return -ENOMEM;
+
+	/* issue efuse read */
+	ret = mtk_efuse_smc(MTK_SIP_EFUSE_READ,
+			    efuse_field, 0x0, 0x0, 0x0,
+			    &res);
+	if (ret < 0)
+		return ret;
+	else if (res.a0 != MTK_EFUSE_SUCCESS) {
+		pr_err("%s : read efuse fail (%lu)\n",
+		       __func__, res.a0);
+		return -1;
+	}
+
+	/* clean read buffer */
+	memset(read_buffer, 0x0, read_buffer_len);
+
+	/* 
+	 * get efuse data 
+	 * maximum data length in one time SMC is 8 bytes
+	 */
+	for (offset = 0; offset < efuse_len; offset += 8) {
+		ret = mtk_efuse_smc(MTK_SIP_EFUSE_GET_DATA,
+				    offset, 8, 0x0, 0x0,
+				    &res);
+		if (ret < 0)
+			return ret;
+		else if (res.a0 != MTK_EFUSE_SUCCESS) {
+			pr_err("%s : get efuse data fail (%lu)\n",
+			       __func__, res.a0);
+			return -1;
+		}
+		efuse_data[0] = res.a2;
+		efuse_data[1] = res.a3;
+
+		for (idx = offset;
+		     idx < (offset + 8) && idx < efuse_len;
+		     idx++)
+		{
+			read_buffer[idx] = ((u8 *)efuse_data)[idx - offset];
+		}
+	}
+
+	return 0;
+}
+
+static int mtk_efuse_write(u32 efuse_field,
+			   u8 *write_buffer,
+			   u32 write_buffer_len)
+{
+	int ret;
+	u32 idx;
+	u32 offset;
+	u32 efuse_len;
+	u32 efuse_data[2] = { 0 };
+	static struct arm_smccc_res res;
+	u32 read_buffer[MTK_EFUSE_PUBK_HASH_INDEX_MAX] = { 0 };
+
+	/* get efuse length */
+	ret = mtk_efuse_smc(MTK_SIP_EFUSE_GET_LEN,
+			    efuse_field, 0x0, 0x0, 0x0,
+			    &res);
+	if (ret < 0)
+		return ret;
+	else if (res.a0 != MTK_EFUSE_SUCCESS) {
+		pr_err("%s : get efuse length fail (%lu)\n",
+		       __func__, res.a0);
+		return -1;
+	}
+	efuse_len = res.a1;
+
+	/* verify buffer */
+	if (!write_buffer)
+		return -EINVAL;
+	if (write_buffer_len < efuse_len)
+		return -ENOMEM;
+
+	/* 
+	 * send efuse data 
+	 * maximum data length in one time SMC is 8 bytes
+	 */
+	for (offset = 0; offset < efuse_len; offset += 8) {
+		memset(efuse_data, 0x0, sizeof(efuse_data));
+
+		for (idx = offset;
+		     idx < (offset + 8) && idx < efuse_len;
+		     idx++) {
+			((u8 *)efuse_data)[idx - offset] = write_buffer[idx];
+		}
+
+		ret = mtk_efuse_smc(MTK_SIP_EFUSE_SEND_DATA,
+				    offset, idx - offset,
+				    efuse_data[0], efuse_data[1],
+				    &res);
+		if (ret < 0)
+			return ret;
+		else if (res.a0 != MTK_EFUSE_SUCCESS) {
+			pr_err("%s : send efuse data fail (%lu)\n",
+			       __func__, res.a0);
+			return -1;
+		}
+	}
+
+	/* 
+	 * get efuse data 
+	 * maximum data length in one time SMC is 8 bytes
+	 */
+	for (offset = 0; offset < efuse_len; offset += 8) {
+		memset(efuse_data, 0x0, sizeof(efuse_data));
+
+		ret = mtk_efuse_smc(MTK_SIP_EFUSE_GET_DATA,
+				    offset, 8, 0x0, 0x0,
+				    &res);
+		if (ret < 0)
+			return ret;
+		else if (res.a0 != MTK_EFUSE_SUCCESS) {
+			pr_err("%s : get efuse data fail (%lu)\n",
+			       __func__, res.a0);
+			return -1;
+		}
+		efuse_data[0] = res.a2;
+		efuse_data[1] = res.a3;
+
+		for (idx = offset;
+		     idx < (offset + 8) && idx < efuse_len;
+		     idx++) {
+			((u8 *)read_buffer)[idx] = 
+				((u8 *)efuse_data)[idx - offset];
+		}
+	}
+
+	/* verify efuse data */
+	if (memcmp(write_buffer, read_buffer, efuse_len)) {
+		pr_err("%s : verify efuse data fail\n", __func__);
+		return -1;
+	}
+
+	/* issue efuse write */
+	ret = mtk_efuse_smc(MTK_SIP_EFUSE_WRITE,
+			    efuse_field, 0x0, 0x0, 0x0,
+			    &res);
+	if (ret < 0)
+		return ret;
+	else if (res.a0 != MTK_EFUSE_SUCCESS) {
+		pr_err("%s : write efuse fail (%lu)\n", __func__, res.a0);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int mtk_efuse_nl_prepare_reply(struct genl_info *info,
+				      u8 cmd,
+				      struct sk_buff **skbp)
+{
+	void *reply;
+        struct sk_buff *skb;
+
+        if (!info)
+		return -EINVAL;
+
+        skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+        if (!skb)
+		return -ENOMEM;
+
+	/* construct send-back message header */
+	reply = genlmsg_put(skb, info->snd_portid, info->snd_seq,
+			    &mtk_efuse_nl_family, 0, cmd);
+	if (!reply) {
+		nlmsg_free(skb);
+		return -EINVAL;
+	}
+
+	*skbp = skb;
+        return 0;
+}
+
+static int mtk_efuse_nl_send_reply(struct sk_buff *skb,
+				   struct genl_info *info)
+{
+        struct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));
+        void *reply = genlmsg_data(genlhdr);
+
+        /* finalize a generic netlink message */
+        genlmsg_end(skb, reply);
+
+        /* reply to a request */
+        return genlmsg_reply(skb, info);
+}
+
+static int mtk_efuse_nl_reply_read(struct genl_info *info)
+{
+	int ret;
+	u32 efuse_field;
+	u32 read_buffer = 0;
+	struct sk_buff *reply_skb = NULL;
+
+	efuse_field =
+		nla_get_u32(info->attrs[MTK_EFUSE_NL_ATTR_TYPE_EFUSE_FIELD]);
+	if (efuse_field >= MTK_EFUSE_FIELD_MAX ||
+	    efuse_field < MTK_EFUSE_FIELD_SBC_PUBK0_HASH_LOCK)
+		return -EINVAL;
+
+	ret = mtk_efuse_nl_prepare_reply(info, MTK_EFUSE_NL_CMD_READ,
+					 &reply_skb);
+	if (ret < 0)
+		goto error;
+
+	ret = mtk_efuse_read(efuse_field, (u8 *)&read_buffer,
+			     sizeof(read_buffer));
+	if (ret < 0)
+		goto error;
+
+	ret = nla_put_u32(reply_skb, MTK_EFUSE_NL_ATTR_TYPE_EFUSE_VALUE,
+			  read_buffer);
+	if (ret < 0)
+		goto error;
+
+        return mtk_efuse_nl_send_reply(reply_skb, info);
+
+error:
+        if (reply_skb)
+		nlmsg_free(reply_skb);
+
+        return ret;
+}
+
+static int mtk_efuse_nl_reply_read_pubk_hash(struct genl_info *info)
+{
+	int ret;
+	u32 idx;
+	u32 efuse_field;
+	struct sk_buff *reply_skb = NULL;
+	u32 read_buffer[MTK_EFUSE_PUBK_HASH_INDEX_MAX] = { 0 };
+
+	efuse_field =
+		nla_get_u32(info->attrs[MTK_EFUSE_NL_ATTR_TYPE_EFUSE_FIELD]);
+	if (efuse_field > MTK_EFUSE_FIELD_SBC_PUBK3_HASH)
+		return -EINVAL;
+
+	ret = mtk_efuse_nl_prepare_reply(info, MTK_EFUSE_NL_CMD_READ_PUBK_HASH,
+					 &reply_skb);
+	if (ret < 0)
+		goto error;
+
+	ret = mtk_efuse_read(efuse_field, (u8 *)&read_buffer[0],
+			     sizeof(read_buffer));
+	if (ret < 0)
+		goto error;
+
+	for (idx = 0; idx < MTK_EFUSE_PUBK_HASH_INDEX_MAX; idx++) {
+		ret = nla_put_u32(reply_skb,
+				  MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH0 + idx,
+				  read_buffer[idx]);
+		if (ret < 0)
+			goto error;
+	}
+
+        return mtk_efuse_nl_send_reply(reply_skb, info);
+
+error:
+        if (reply_skb)
+		nlmsg_free(reply_skb);
+
+        return ret;
+}
+
+static int mtk_efuse_nl_reply_write(struct genl_info *info)
+{
+	int ret;
+	u32 efuse_field;
+	u32 write_buffer;
+
+	efuse_field =
+		nla_get_u32(info->attrs[MTK_EFUSE_NL_ATTR_TYPE_EFUSE_FIELD]);
+	if (efuse_field >= MTK_EFUSE_FIELD_MAX ||
+	    efuse_field < MTK_EFUSE_FIELD_SBC_PUBK0_HASH_LOCK)
+		return -EINVAL;
+
+	write_buffer =
+		nla_get_u32(info->attrs[MTK_EFUSE_NL_ATTR_TYPE_EFUSE_VALUE]);
+
+	ret = mtk_efuse_write(efuse_field, (u8 *)&write_buffer,
+			      sizeof(write_buffer));
+
+	return ret;
+}
+
+static int mtk_efuse_nl_reply_write_pubk_hash(struct genl_info *info)
+{
+	int ret;
+	u32 idx;
+	u32 efuse_field;
+	u32 write_buffer[MTK_EFUSE_PUBK_HASH_INDEX_MAX] = { 0 };
+
+	efuse_field =
+		nla_get_u32(info->attrs[MTK_EFUSE_NL_ATTR_TYPE_EFUSE_FIELD]);
+	if (efuse_field > MTK_EFUSE_FIELD_SBC_PUBK3_HASH)
+		return -EINVAL;
+
+	for (idx = 0; idx < MTK_EFUSE_PUBK_HASH_INDEX_MAX; idx++) {
+		write_buffer[idx] = 
+			nla_get_u32(
+			info->attrs[MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH0 + idx]);
+	}
+
+	ret = mtk_efuse_write(efuse_field, (u8 *)&write_buffer[0],
+			      sizeof(write_buffer));
+
+	return ret;
+}
+
+static int mtk_efuse_nl_reply_update_ar_ver(struct genl_info *info)
+{
+	int ret;
+	struct arm_smccc_res res;
+
+	/* issue update anti-rollback version*/
+	ret = mtk_efuse_smc(MTK_SIP_EFUSE_UPDATE_AR_VER,
+			    0x0, 0x0, 0x0, 0x0,
+			    &res);
+	if (ret < 0)
+		return ret;
+	else if (res.a0 != MTK_EFUSE_SUCCESS) {
+		pr_err("%s : update anti-rollback version fail (%lu)\n"
+		       , __func__, res.a0);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int mtk_efuse_nl_response(struct sk_buff *skb, struct genl_info *info)
+{
+	int idx;
+        u32 nl_cmd_attrs_num = 0;
+        const struct mtk_efuse_nl_cmd_t *cmditem = NULL;
+        struct genlmsghdr *hdr = nlmsg_data(info->nlhdr);
+
+	for (idx = 0; idx < ARRAY_SIZE(mtk_efuse_nl_cmds); idx++) {
+		if (hdr->cmd == mtk_efuse_nl_cmds[idx].cmd) {
+			cmditem = &mtk_efuse_nl_cmds[idx];
+			break;
+		}
+	}
+
+	if (!cmditem) {
+		pr_err("%s : unknown cmd %u\n", __func__, hdr->cmd);
+		return -EINVAL;
+	}
+
+	for (idx = 0; idx < cmditem->req_attrs_num; idx++) {
+		if (info->attrs[cmditem->req_attrs[idx]])
+			nl_cmd_attrs_num++;
+	}
+
+	if (nl_cmd_attrs_num != cmditem->req_attrs_num) {
+		pr_err("%s : missing required attr(s) for cmd %u\n",
+		       __func__, hdr->cmd);
+		return -EINVAL;
+	}
+
+	return cmditem->process(info);
+}
+
+static int __init mtk_efuse_nl_init(void)
+{
+	int ret;
+
+	ret = genl_register_family(&mtk_efuse_nl_family);
+	if (ret) {
+		pr_err("%s : genl_register_family fail (%d)\n",
+		       __func__, ret);
+		return ret;
+	}
+
+	pr_info("%s : netlink family \"mtk-efuse\" register success\n",
+		__func__);
+        return 0;
+}
+
+static void __exit mtk_efuse_nl_exit(void)
+{
+	genl_unregister_family(&mtk_efuse_nl_family);
+
+	pr_info("%s : netlink family \"mtk-efuse\" unregister success\n",
+		__func__);
+}
+
+module_init(mtk_efuse_nl_init);
+module_exit(mtk_efuse_nl_exit);
+
+MODULE_DESCRIPTION("Mediatek eFuse driver");
+MODULE_LICENSE("GPL");
diff --git a/openwrt/package/mtk_soc/drivers/mtk-efuse-nl-drv/src/mtk_efuse.h b/openwrt/package/mtk_soc/drivers/mtk-efuse-nl-drv/src/mtk_efuse.h
new file mode 100755
index 0000000..5a964f4
--- /dev/null
+++ b/openwrt/package/mtk_soc/drivers/mtk-efuse-nl-drv/src/mtk_efuse.h
@@ -0,0 +1,199 @@
+/* SPDX-License-Identifier:	GPL-2.0+ */
+/*
+ * Copyright (C) 2021 MediaTek Incorporation. All Rights Reserved.
+ *
+ * Author: Alvin Kuo <Alvin.Kuo@mediatek.com>
+ */
+#ifndef __MTK_EFUSE_H__
+#define __MTK_EFUSE_H__
+
+/*********************************************************************************
+ *
+ *  Returned status of eFuse SMC
+ *
+ ********************************************************************************/
+#define MTK_EFUSE_SUCCESS                                       0x00000000
+#define MTK_EFUSE_ERROR_INVALIDE_PARAMTER                       0x00000001
+#define MTK_EFUSE_ERROR_INVALIDE_EFUSE_FIELD                    0x00000002
+#define MTK_EFUSE_ERROR_EFUSE_FIELD_DISABLED                    0x00000003
+#define MTK_EFUSE_ERROR_EFUSE_LEN_EXCEED_BUFFER_LEN             0x00000004
+#define MTK_EFUSE_ERROR_READ_EFUSE_FIELD_FAIL                   0x00000005
+#define MTK_EFUSE_ERROR_WRITE_EFUSE_FIELD_FAIL                  0x00000006
+
+/*********************************************************************************
+ *
+ *  Function ID of eFuse SMC
+ *
+ ********************************************************************************/
+/*
+ *  MTK_SIP_EFUSE_GET_LEN - get data length of efuse field
+ *
+ *  parameters
+ *  @x1:        efuse field
+ *
+ *  return
+ *  @r0:        status
+ *  @r1:        data length
+ */
+#define MTK_SIP_EFUSE_GET_LEN           0x82000501
+
+/*
+ *  MTK_SIP_EFUSE_SEND_DATA - send data to efuse buffer
+ *
+ *  parameters
+ *  @x1:        data offset, 0 ~ 24 bytes
+ *  @x2:        data length, 0 ~ 8 bytes
+ *  @x3:        data, bytes 0 to 3
+ *  @x4:        data, bytes 4 to 7
+ *
+ *  return
+ *  @r0:        status
+ *  @r1:        data length
+ */
+#define MTK_SIP_EFUSE_SEND_DATA         0x82000502
+
+/*
+ *  MTK_SIP_EFUSE_GET_DATA - get data from efuse buffer
+ *
+ *  parameters
+ *  @x1:        data offset, 0 ~ 24 bytes
+ *  @x2:        data length, 0 ~ 8 bytes
+ *
+ *  return
+ *  @r0:        status
+ *  @r1:        data length
+ *  @r2:        data, bytes 0 to 3
+ *  @r3:        data, bytes 4 to 7
+ */
+#define MTK_SIP_EFUSE_GET_DATA          0x82000503
+
+/*
+ *  MTK_SIP_EFUSE_WRITE - write efuse field
+ *
+ *  parameters
+ *  @x1:        efuse field
+ *
+ *  return
+ *  @r0:        status
+ */
+#define MTK_SIP_EFUSE_WRITE             0x82000504
+
+/*
+ *  MTK_SIP_EFUSE_READ - read efuse field
+ *
+ *  parameters
+ *  @x1:        efuse field
+ *
+ *  return
+ *  @r0:        status
+ */
+#define MTK_SIP_EFUSE_READ              0x82000505
+
+/*
+ *  MTK_SIP_EFUSE_DISABLE - disable efuse field
+ *
+ *  parameters
+ *  @x1:        efuse field
+ *
+ *  return
+ *  @r0:        status
+ */
+#define MTK_SIP_EFUSE_DISABLE		0x82000506
+
+/*
+ *  MTK_SIP_EFUSE_UPDATE_AR_VER - update anti-rollback version
+ *
+ *  return
+ *  @r0:        status
+ */
+#define MTK_SIP_EFUSE_UPDATE_AR_VER	0x82000510
+
+/*********************************************************************************
+ *
+ *  eFuse info (DO NOT EDIT, it copy from ATF)
+ *
+ ********************************************************************************/
+enum MTK_EFUSE_FIELD {
+	MTK_EFUSE_FIELD_SBC_PUBK0_HASH = 0,
+	MTK_EFUSE_FIELD_SBC_PUBK1_HASH,
+	MTK_EFUSE_FIELD_SBC_PUBK2_HASH,
+	MTK_EFUSE_FIELD_SBC_PUBK3_HASH,
+	MTK_EFUSE_FIELD_SBC_PUBK0_HASH_LOCK,
+	MTK_EFUSE_FIELD_SBC_PUBK1_HASH_LOCK,
+	MTK_EFUSE_FIELD_SBC_PUBK2_HASH_LOCK,
+	MTK_EFUSE_FIELD_SBC_PUBK3_HASH_LOCK,
+	MTK_EFUSE_FIELD_SBC_PUBK0_HASH_DIS,
+	MTK_EFUSE_FIELD_SBC_PUBK1_HASH_DIS,
+	MTK_EFUSE_FIELD_SBC_PUBK2_HASH_DIS,
+	MTK_EFUSE_FIELD_SBC_PUBK3_HASH_DIS,
+	MTK_EFUSE_FIELD_JTAG_DIS,
+	MTK_EFUSE_FIELD_SBC_EN,
+	MTK_EFUSE_FIELD_AR_EN,
+	MTK_EFUSE_FIELD_DAA_EN,
+	MTK_EFUSE_FIELD_BROM_CMD_DIS,
+	MTK_EFUSE_FIELD_BL_AR_VER0,
+	MTK_EFUSE_FIELD_BL_AR_VER1,
+	MTK_EFUSE_FIELD_BL_AR_VER2,
+	MTK_EFUSE_FIELD_BL_AR_VER3,
+	MTK_EFUSE_FIELD_FW_AR_VER0,
+	MTK_EFUSE_FIELD_FW_AR_VER1,
+	__MTK_EFUSE_FIELD_MAX,
+};
+#define MTK_EFUSE_FIELD_MAX (__MTK_EFUSE_FIELD_MAX)
+
+enum MTK_EFUSE_PUBK_HASH_INDEX {
+	MTK_EFUSE_PUBK_HASH_INDEX0 = 0,
+	MTK_EFUSE_PUBK_HASH_INDEX1,
+	MTK_EFUSE_PUBK_HASH_INDEX2,
+	MTK_EFUSE_PUBK_HASH_INDEX3,
+	MTK_EFUSE_PUBK_HASH_INDEX4,
+	MTK_EFUSE_PUBK_HASH_INDEX5,
+	MTK_EFUSE_PUBK_HASH_INDEX6,
+	MTK_EFUSE_PUBK_HASH_INDEX7,
+	__MTK_EFUSE_PUBK_HASH_INDEX_MAX,
+};
+#define MTK_EFUSE_PUBK_HASH_INDEX_MAX (__MTK_EFUSE_PUBK_HASH_INDEX_MAX)
+
+/*********************************************************************************
+ *
+ *  netlink info
+ *
+ ********************************************************************************/
+#define MTK_EFUSE_NL_GENL_NAME			"mtk-efuse"
+#define MTK_EFUSE_NL_GENL_VERSION		0x1
+
+enum MTK_EFUSE_NL_CMD {
+	MTK_EFUSE_NL_CMD_UNSPEC = 0,
+	MTK_EFUSE_NL_CMD_READ,
+	MTK_EFUSE_NL_CMD_READ_PUBK_HASH,
+	MTK_EFUSE_NL_CMD_WRITE,
+	MTK_EFUSE_NL_CMD_WRITE_PUBK_HASH,
+	MTK_EFUSE_NL_CMD_UPDATE_AR_VER,
+	__MTK_EFUSE_NL_CMD_MAX
+};
+#define MTK_EFUSE_NL_CMD_MAX (__MTK_EFUSE_NL_CMD_MAX - 1)
+
+enum MTK_EFUSE_NL_ATTR_TYPE {
+	MTK_EFUSE_NL_ATTR_TYPE_UNSPEC = 0,
+	MTK_EFUSE_NL_ATTR_TYPE_EFUSE_FIELD,
+	MTK_EFUSE_NL_ATTR_TYPE_EFUSE_VALUE,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH0,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH1,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH2,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH3,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH4,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH5,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH6,
+	MTK_EFUSE_NL_ATTR_TYPE_PUBK_HASH7,
+	__MTK_EFUSE_NL_ATTR_TYPE_MAX,
+};
+#define MTK_EFUSE_NL_ATTR_TYPE_MAX (__MTK_EFUSE_NL_ATTR_TYPE_MAX - 1)
+
+static int mtk_efuse_nl_reply_read(struct genl_info *info);
+static int mtk_efuse_nl_reply_read_pubk_hash(struct genl_info *info);
+static int mtk_efuse_nl_reply_write(struct genl_info *info);
+static int mtk_efuse_nl_reply_write_pubk_hash(struct genl_info *info);
+static int mtk_efuse_nl_reply_update_ar_ver(struct genl_info *info);
+static int mtk_efuse_nl_response(struct sk_buff *skb, struct genl_info *info);
+
+#endif /* __MTK_EFUSE_H__ */
-- 
2.7.4

